===== PHASE 3: CODER PROMPT =====
You are a senior TypeScript engineer implementing Phase {{PHASE}} of Project 03 (script harness). Read every referenced doc, apply Cody dev standards, and update checklist/decisions as you work.


---

PRODUCT:

Cody (CLI + library) now supports script-based tool calling alongside structured function calls. Scripts are TypeScript snippets wrapped in `<tool-calls>` blocks that run inside a hardened QuickJS runtime and route through the existing tool registry, approvals, and persistence layers.


---

PROJECT CONTEXT:

- **Goal:** Make script harness a first-class capability so models can compose multiple tools in a single turn while sharing the same tool registry as structured calls.
- **Why:** Structured tool calls require one JSON payload per turn; scripts shrink multi-step workflows, unlock cheap models, and provide deterministic automation for humans.
- **Deliverables:** End-to-end harness, CLI/REST UX, documentation, and benchmark report showing improved workflow completion rates.
- **Constraints:** QuickJS sandbox only, scripts capped at 20 KB / 32 tool calls / 5 s runtime, no direct host APIs, approvals identical to structured path.


---

PHASE 3 TECHNICAL DESIGN:

# Phase 3 Design – Promise Lifecycle & Detached Tasks

## Objective
Track every async tool call, cancel leaked promises, and add `tools.spawn.*` APIs for detached tasks that survive beyond the current script turn.

## Components

1. **PromiseTracker:** registers all awaited tool calls, associates them with AbortSignals, and cancels outstanding work when scripts finish or abort. Provides helpful diagnostics when a promise leaks (`exec @ script.ts:12 never resolved`).
2. **Spawn Manager:** implements `tools.spawn.<toolName>()` returning handles with `.done`, `.cancel`, `.status`. Spawned tasks continue running after the script returns; results surface in subsequent turns via conversation history.
3. **CLI Task UI:** displays running tool calls (spinners) and a summary banner listing completed vs running tasks. Adds command to list detached tasks.

## Notes
- Persist detached task metadata (id, tool, status) to conversation state so future scripts or structured turns can inspect them.
- Ctrl+C or turn timeout cancels active tasks unless explicitly detached.


---

TEST CONDITIONS:

# Phase 3 Test Conditions

1. Tracker cancels pending promises when script exits normally (mock tool resolves after delay → ensure cancellation occurs).
2. Ctrl+C (simulated) aborts running tools and surfaces `ScriptCanceledError`.
3. `tools.spawn.exec` returns handle whose `.done` resolves after script completes; status persisted to history.
4. Detached task result surfaces next turn (mock pipeline ensures conversation history carries task output).
5. CLI displays running/completed counts and `scripts tasks` command lists active handles.


---

TASKS (update source/checklist.md as you work):

# Checklist – Phase 3

- [ ] Implement PromiseTracker with leak diagnostics
- [ ] Add AbortSignal wiring to tool facade
- [ ] Build tools.spawn API + SpawnManager
- [ ] Persist detached task metadata
- [ ] Update CLI with running/completed summaries + tasks command
- [ ] Tests per test-conditions.md
- [ ] Manual script walkthrough


---

STANDARDS:

See docs/core/dev-standards.md for complete coding standards.
See docs/core/contract-testing-tdd-philosophy.md for testing approach.

Key requirements:
- TypeScript strict mode, no any types
- ESLint 0 errors
- Prettier formatted
- Mocked-service tests at library boundaries
- Mock all external dependencies


---

EXECUTION WORKFLOW:

1. Read artifacts (design, tests, manual script, checklist) and relevant source files.
2. Write/extend mocked-service tests first until they fail for the right reason.
3. Implement code to satisfy tests, following dev standards and keeping approvals/tool registry invariants intact.
4. Run manual script checklist if provided.
5. Update checklist.md (mark completed tasks) and record noteworthy choices in decisions.md.


---

MANUAL VERIFICATION:

# Phase 3 Manual Script

1. Run script spawning long-running exec:
   ```
   const build = tools.spawn.exec({command: ['sleep','5']});
   console.log('started', build.id);
   await tools.exec({command:['echo','done']});
   ```
2. Observe CLI summary showing one detached task. Run `cody scripts tasks` to view status.
3. In next turn, query tasks to confirm completion.
4. Press Ctrl+C during script and ensure pending tasks cancel with friendly message.


---

FINAL QUALITY CHECK:

Before declaring phase complete:

Run: npm run format && npm run lint && npx tsc --noEmit && npm test

ALL must pass. Document results.
Update checklist.md and decisions.md.
Commit and push.
Ready for verification stages.

===== END CODER PROMPT =====
