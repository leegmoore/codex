===== PHASE 5: CODER PROMPT =====
You are a senior TypeScript engineer implementing Phase {{PHASE}} of Project 03 (script harness). Read every referenced doc, apply Cody dev standards, and update checklist/decisions as you work.


---

PRODUCT:

Cody (CLI + library) now supports script-based tool calling alongside structured function calls. Scripts are TypeScript snippets wrapped in `<tool-calls>` blocks that run inside a hardened QuickJS runtime and route through the existing tool registry, approvals, and persistence layers.


---

PROJECT CONTEXT:

- **Goal:** Make script harness a first-class capability so models can compose multiple tools in a single turn while sharing the same tool registry as structured calls.
- **Why:** Structured tool calls require one JSON payload per turn; scripts shrink multi-step workflows, unlock cheap models, and provide deterministic automation for humans.
- **Deliverables:** End-to-end harness, CLI/REST UX, documentation, and benchmark report showing improved workflow completion rates.
- **Constraints:** QuickJS sandbox only, scripts capped at 20 KB / 32 tool calls / 5 s runtime, no direct host APIs, approvals identical to structured path.


---

PHASE 5 TECHNICAL DESIGN:

# Phase 5 Design – Performance & Security Hardening

## Objective
Make the harness production-ready by pooling QuickJS workers, caching scripts/compilation output, enforcing resource limits, and adding security/observability hooks.

## Components

1. **Worker Pool:** maintains `min(2, cpuCount)` warm QuickJS workers, recycles contexts after N scripts or contamination, measures utilization.
2. **Script + Compilation Cache:** caches transpiled TypeScript and QuickJS bytecode keyed by script hash; invalidates on hash change.
3. **Resource Monitor:** enforces limits (size, call count, concurrency, runtime, memory). Exceeding limits throws structured errors linking to docs.
4. **Security/Fuzz Tests:** attempt banned tokens, prototype pollution, runaway loops, log spam; ensure deterministic failures.
5. **Metrics & Logging:** emit pool stats, cache hit rate, script durations, error categories.


---

TEST CONDITIONS:

# Phase 5 Test Conditions

1. Worker pool reuse: borrow/release workers and verify warm execution <20 ms.
2. Cache hit: same script twice uses cached bytecode/transpile output.
3. Cache invalidation: modified script hash causes recompilation.
4. Resource limit enforcement: oversize script, too many tool calls, long runtime, and excessive memory each trigger correct error.
5. Security fuzz: eval/Function attempts rejected; prototype pollution prevented; while(true) hits timeout; console spam rate-limited.
6. Metrics reporting: mock logger receives pool utilization + error stats.


---

TASKS (update source/checklist.md as you work):

# Checklist – Phase 5

- [ ] Implement worker pool + recycling
- [ ] Add script + compilation cache
- [ ] Build resource monitor enforcing all limits
- [ ] Add metrics/logging hooks
- [ ] Expand docs with limit explanations
- [ ] Tests per test-conditions.md
- [ ] Manual performance/security walkthrough


---

STANDARDS:

See docs/core/dev-standards.md for complete coding standards.
See docs/core/contract-testing-tdd-philosophy.md for testing approach.

Key requirements:
- TypeScript strict mode, no any types
- ESLint 0 errors
- Prettier formatted
- Mocked-service tests at library boundaries
- Mock all external dependencies


---

EXECUTION WORKFLOW:

1. Read artifacts (design, tests, manual script, checklist) and relevant source files.
2. Write/extend mocked-service tests first until they fail for the right reason.
3. Implement code to satisfy tests, following dev standards and keeping approvals/tool registry invariants intact.
4. Run manual script checklist if provided.
5. Update checklist.md (mark completed tasks) and record noteworthy choices in decisions.md.


---

MANUAL VERIFICATION:

# Phase 5 Manual Checklist

1. Run benchmark script repeatedly; monitor CLI log for cache hit info and confirm executions stay under target latency.
2. Intentionally run script exceeding runtime limit to verify friendly error.
3. Trigger banned token (eval) and prototype pollution attempt; ensure errors match docs.
4. Inspect metrics endpoint/logs for pool utilization and cache stats.


---

FINAL QUALITY CHECK:

Before declaring phase complete:

Run: npm run format && npm run lint && npx tsc --noEmit && npm test

ALL must pass. Document results.
Update checklist.md and decisions.md.
Commit and push.
Ready for verification stages.

===== END CODER PROMPT =====
