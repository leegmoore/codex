===== PHASE 1: CODER PROMPT =====
You are a senior TypeScript engineer implementing Phase {{PHASE}} of Project 03 (script harness). Read every referenced doc, apply Cody dev standards, and update checklist/decisions as you work.


---

PRODUCT:

Cody (CLI + library) now supports script-based tool calling alongside structured function calls. Scripts are TypeScript snippets wrapped in `<tool-calls>` blocks that run inside a hardened QuickJS runtime and route through the existing tool registry, approvals, and persistence layers.


---

PROJECT CONTEXT:

- **Goal:** Make script harness a first-class capability so models can compose multiple tools in a single turn while sharing the same tool registry as structured calls.
- **Why:** Structured tool calls require one JSON payload per turn; scripts shrink multi-step workflows, unlock cheap models, and provide deterministic automation for humans.
- **Deliverables:** End-to-end harness, CLI/REST UX, documentation, and benchmark report showing improved workflow completion rates.
- **Constraints:** QuickJS sandbox only, scripts capped at 20 KB / 32 tool calls / 5 s runtime, no direct host APIs, approvals identical to structured path.


---

PHASE 1 TECHNICAL DESIGN:

# Phase 1 Design – Detection & Basic Execution

## Objective
Detect `<tool-calls>` script blocks in assistant responses, validate TypeScript snippets, and execute them in a hardened QuickJS runtime with support for `exec`, `readFile`, and `applyPatch` tools. Emit results back into the conversation loop and surface script activity in the CLI.

## Components

1. **Script Detector (`script_detector.ts`):**
   - Scan assistant messages (ResponseItems) for `<tool-calls>...</tool-calls>` using regex.
   - Ignore other roles/types.
   - Support multiple blocks; record start/end indices for logging.

2. **Script Parser (`script_parser.ts`):**
   - Enforce limits: UTF-8, <=20 KB, balanced tags, banned tokens (`require`, `import`, `eval`, `new Function`).
   - Syntax-check via TypeScript transpile probe; auto-wrap with async IIFE when top-level await found.
   - Return `{success, script, error}` with helpful messages.

3. **QuickJS Orchestrator (`script_orchestrator.ts`):**
   - Use quickjs-emscripten to create context per execution (Phase 1 = no pool yet).
   - Apply hardening shim (freeze intrinsics, delete eval/Function/etc.).
   - Inject globals: `tools`, `context`, `console` (rate-limited).
   - Execute script, convert returned value into `ScriptToolCallOutput` items.
   - Capture runtime errors, shorten stack traces to user code.

4. **Minimal Tool Facade:**
   - Expose `tools.exec`, `tools.readFile`, `tools.applyPatch` via proxy that validates arguments and calls existing tool implementations.
   - No approvals yet; rely on existing structured path (Phase 4 adds pause/resume).

5. **CLI Updates:**
   - Display banner `▶️ Running script (hash …)` when script starts.
   - Stream console.log output to CLI (prefix `[script]`).
   - When script finishes, show summary (duration, tools used).

## Error Handling
- Parser errors → ResponseItems with `ScriptParseError`, showing snippet + message.
- Runtime errors → `ScriptRuntimeError` with stack trimmed to script lines.
- Tool errors propagate as structured errors (JSON string with `error` field).

## References
- QuickJS runtime binding (existing Phase 4.4 prototype).
- Tool implementations: `codex-ts/src/tools/*`.
- Response processing pipeline: `codex-ts/src/core/response_processing`.


---

TEST CONDITIONS:

# Phase 1 Test Conditions

1. **Detector finds single block** – assistant message with one `<tool-calls>` block returns ScriptBlock array length 1 with correct code.
2. **Detector ignores user/tool items** – ensure no false positives.
3. **Parser rejects banned token** – script containing `require('fs')` throws error with helpful message.
4. **Parser wraps top-level await** – script `const x = await tools.readFile(...)` compiles and runs.
5. **QuickJS executes script** – integration test: script runs `await tools.exec({command:['pwd']})`, result captured as FunctionCallOutput.
6. **Runtime error trimmed** – script `throw new Error('boom')` shows trimmed stack (no QuickJS internals).
7. **CLI banner/log output** – simulated ResponseItems produce ANSI log lines containing hash + snippet.


---

TASKS (update source/checklist.md as you work):

# Checklist – Phase 1

- [ ] Implement script detector (XML scanning, tests)
- [ ] Build parser with validation + async wrapping
- [ ] Integrate detector/parser into response processing
- [ ] Add QuickJS orchestrator (single worker)
- [ ] Create minimal tool facade (exec/readFile/applyPatch)
- [ ] Emit ScriptToolCallOutput items
- [ ] Update CLI banner/log streaming
- [ ] Write mocked-service tests (detection, parsing, execution)
- [ ] Run manual script tests
- [ ] Document behavior in docs/script-harness.md


---

STANDARDS:

See docs/core/dev-standards.md for complete coding standards.
See docs/core/contract-testing-tdd-philosophy.md for testing approach.

Key requirements:
- TypeScript strict mode, no any types
- ESLint 0 errors
- Prettier formatted
- Mocked-service tests at library boundaries
- Mock all external dependencies


---

EXECUTION WORKFLOW:

1. Read artifacts (design, tests, manual script, checklist) and relevant source files.
2. Write/extend mocked-service tests first until they fail for the right reason.
3. Implement code to satisfy tests, following dev standards and keeping approvals/tool registry invariants intact.
4. Run manual script checklist if provided.
5. Update checklist.md (mark completed tasks) and record noteworthy choices in decisions.md.


---

MANUAL VERIFICATION:

# Phase 1 Manual Test Script

1. Start CLI (`npm run build && cody new`).
2. Paste prompt containing script:
   ```
   <tool-calls>
   const result = await tools.exec({command: ['pwd']});
   console.log('pwd:', result.stdout.trim());
   </tool-calls>
   ```
3. Expect banner + console output, followed by assistant message summarizing result.
4. Paste script with banned token (`require('fs')`) → CLI shows parser error.
5. Paste two scripts in one turn → both execute sequentially.
6. Induce runtime error (`throw new Error('oops')`) → CLI displays ScriptRuntimeError with snippet.


---

FINAL QUALITY CHECK:

Before declaring phase complete:

Run: npm run format && npm run lint && npx tsc --noEmit && npm test

ALL must pass. Document results.
Update checklist.md and decisions.md.
Commit and push.
Ready for verification stages.

===== END CODER PROMPT =====
