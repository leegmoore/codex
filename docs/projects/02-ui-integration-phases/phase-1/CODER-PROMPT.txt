===== PHASE 1: BASIC CHAT FLOW - CODER PROMPT =====

ROLE: Senior TypeScript developer implementing Phase 1 of Cody CLI integration

PRODUCT: Cody - Command-line interface for the Codex TypeScript library
A multi-provider LLM agent CLI supporting OpenAI (Responses, Chat) and Anthropic (Messages) APIs with tool execution, conversation persistence, and extensible architecture.

PROJECT: Project 02 - UI Integration & Library Definition
Integrate all ported Codex modules (Phases 1-6 from Rust port) into working CLI called Cody. Validate port completion through end-to-end workflows. Define library API for external developers. Implement REST API for web/mobile clients.

PHASE 1: Basic Chat Flow
Wire CLI → ConversationManager → Codex → Session → ModelClient for basic conversation capability. Implement commands (cody new, cody chat) with single provider (OpenAI Responses API) and single auth method (API key). Prove end-to-end conversation flow works. This is first time ported components talk to each other.

FUNCTIONAL OUTCOME:
User can start conversation, send messages, receive responses, have multi-turn chat with context maintained. Commands: cody new (create conversation), cody chat "message" (send and display response).

---

REFERENCES (Read Before Coding):

Required reading:
1. docs/projects/02-ui-integration-phases/PRD.md
   - Section 1: Overview (what we're building)
   - Section 2: Success Criteria (what must work)
   - Section 5: Quality Standards (testing, code quality)

2. docs/projects/02-ui-integration-phases/TECH-APPROACH.md
   - Section 1: Architecture Overview (system structure, current state & deltas)
   - Section 2: Phase 1 Deep Dive (integration approach, diagrams, contracts, verification)

3. docs/core/dev-standards.md
   - TypeScript strict mode, ESLint rules, Prettier formatting
   - Coding conventions, naming patterns

4. docs/core/contract-testing-tdd-philosophy.md
   - Mocked-service testing approach
   - Test at library boundaries, mock externals
   - TDD workflow

Optional (reference as needed):
- Ported code: codex-ts/src/core/conversation-manager.ts (read for actual signatures)
- Ported code: codex-ts/src/core/codex/ (Session, Codex implementation)
- Ported code: codex-ts/src/client/ (ModelClient, Responses adapter)

---

KEY STANDARDS FOR THIS PHASE:

Code Quality:
- TypeScript strict: no any types, use unknown or proper types
- ESLint: 0 errors enforced (warnings OK if pre-existing)
- Prettier: format before commits (npm run format)
- Imports: Use .js extensions (ESM), proper relative paths

Testing:
- Write mocked-service tests FIRST (TDD approach)
- Tests in: tests/mocked-service/phase-1-conversation-flow.test.ts
- Mock ModelClient (no real API calls), mock Config
- Test functional outcomes: can create conversation, can send message, history maintained
- Minimum 3 tests: create conversation, send message, multi-turn history

Integration:
- Use existing ported modules AS-IS (don't refactor core)
- CLI is thin wrapper around library (business logic stays in core)
- If API issues found, STOP and report (don't redesign on your own)

Verification Commands (run after coding):
npm run format && npm run lint && npx tsc --noEmit && npm test

All must pass (0 errors) before marking phase complete.

---

DETAILED TASKS (see CHECKLIST.md):

The CHECKLIST.md file in this directory contains numbered tasks for this phase.
As you complete each task, check it off in CHECKLIST.md.
Update CHECKLIST.md as you work—it's your progress tracker.

High-level task groups:
1. Setup (create CLI directories, install Commander.js)
2. Config loading (read ~/.codex/config.toml)
3. ModelClient construction (from config: provider, model, auth)
4. ConversationManager wiring (inject ModelClient, create conversation)
5. CLI commands (cody new, cody chat)
6. Display renderer (console output for responses)
7. Mocked-service tests (conversation flow with mocked client)
8. Functional verification (manual CLI testing)
9. Quality gates (format, lint, typecheck, tests all pass)

See CHECKLIST.md for complete breakdown (20-30 discrete tasks).

---

CONTRACTS BEING IMPLEMENTED:

From TECH-APPROACH Section 2:

ConversationManager.createConversation():
- Input: ConversationConfig {provider, model, auth}
- Output: Promise<Conversation>
- Side effects: Conversation stored in manager
- Errors: ConfigurationError if invalid

Conversation.sendMessage():
- Input: message: string
- Output: Promise<ResponseItems[]>
- Side effects: Message added to history, sent to model, response recorded
- Errors: NetworkError, AuthError

Test these contracts in mocked-service tests.

---

DECISIONS LOG:

As you make implementation choices that don't require user approval, log them in DECISIONS.md.

Examples of loggable decisions:
- CLI directory structure chosen (src/cli/)
- Commander.js command registration pattern
- How ModelClient gets injected into ConversationManager
- Display rendering approach (batch vs streaming for Phase 1)
- Mock implementation strategy

Format: Brief entry with rationale. User reviews later.

---

EXECUTION WORKFLOW:

1. Read all reference docs (PRD, TECH-APPROACH Section 1 & 2, standards)
2. Review CHECKLIST.md (understand all tasks)
3. Create mocked-service tests FIRST (TDD)
   - tests/mocked-service/phase-1-conversation-flow.test.ts
   - Mock ModelClient, mock Config
   - Write 3+ tests covering contracts
4. Run tests (should fail - nothing implemented yet)
5. Implement CLI layer:
   - Command parser (Commander.js)
   - Config loader
   - ModelClient construction
   - ConversationManager wiring
   - Display renderer
6. Run tests after each major component (iterate to green)
7. Functional testing (manual):
   - cody new → creates conversation
   - cody chat "Hello" → gets response
   - cody chat "What did I say?" → has context
8. Quality verification:
   - npm run format (fix formatting)
   - npm run lint (fix any errors)
   - npx tsc --noEmit (fix type errors)
   - npm test (all pass)
   - Run combined: npm run format && npm run lint && npx tsc --noEmit && npm test
9. Update CHECKLIST.md (check off completed tasks)
10. Review DECISIONS.md (ensure all choices documented)
11. Commit and push

---

BEFORE DECLARING COMPLETE:

- [ ] All CHECKLIST tasks checked off
- [ ] All mocked-service tests passing
- [ ] Unit test baseline maintained (1,876+ tests still passing)
- [ ] Functional verification complete (manual CLI testing worked)
- [ ] Quality checks all pass (format, lint, typecheck, tests)
- [ ] DECISIONS.md has meaningful entries
- [ ] Code committed and pushed
- [ ] Ready for quality verification (Stage 1) and code review (Stage 2)

DO NOT declare complete until all items above verified.

---

HELP / BLOCKERS:

If you encounter:
- Ported module API doesn't work as expected
- Can't figure out how to wire components
- Tests reveal integration issues
- Unclear how to implement something

STOP and document the blocker. Ask user for guidance. Don't guess or redesign.

---

GO: Start by reading PRD Section 1-2, TECH-APPROACH Section 1-2. Then review CHECKLIST.md. Then begin with mocked-service tests.
