### Validation Criteria

The v2 system is complete when:
- All ported tests pass
- Request payloads to OpenAI API are structurally identical to Rust Codex requests (validated via request logging/comparison)
- Tool outputs preserve structured data through the full pipeline
- SSE deltas display progressively in frontend
- No transformation pipeline exists between session storage and API submission


=== BEGIN WORK ===


Execute your current task following the test-first process. Update logs before finishing.

ERROR: MCP client for `RepoPrompt` failed to start: timed out handshaking with MCP server after 10s

thinking
**Verifying log files on disk**
exec
/bin/zsh -lc 'cat codys-log.md' in /Users/leemoore/code/v/codex-port exited 1 in 21ms:
cat: codys-log.md: No such file or directory

thinking
**Searching for codys-log file**
exec
/bin/zsh -lc "rg --files -g 'codys-log.md'" in /Users/leemoore/code/v/codex-port exited 1 in 42ms:


thinking
**Searching for Cody's Work Log file**
exec
/bin/zsh -lc "rg \"Cody's Work Log\"" in /Users/leemoore/code/v/codex-port exited 1 in 33ms:


thinking
**Checking for decision log file**
exec
/bin/zsh -lc "rg --files -g 'decision-log.md'" in /Users/leemoore/code/v/codex-port exited 1 in 21ms:


thinking
**Searching for capitalized DECISION-LOG.md**
exec
/bin/zsh -lc "rg --files -g 'DECISION-LOG.md'" in /Users/leemoore/code/v/codex-port exited 1 in 27ms:


thinking
**Checking .cody directory**
exec
/bin/zsh -lc ls in /Users/leemoore/code/v/codex-port succeeded in 12ms:
bun.lock
docs
logs
node_modules
package.json
README.md
scripts
src
tests
tmp
tsconfig.json
user-feedback-questions.md
web

thinking
**Checking logs directory**
exec
/bin/zsh -lc 'ls logs' in /Users/leemoore/code/v/codex-port succeeded in 15ms:
server.err.log
server.err.log.20251025185449
server.err.log.bak.log
server.out.log
server.out.log.20251025185440
server.out.log.bak.log

thinking
**Checking documentation for logs**
exec
/bin/zsh -lc 'ls docs' in /Users/leemoore/code/v/codex-port succeeded in 10ms:
openai-responses-api.md

thinking
**Checking test directory contents**
exec
/bin/zsh -lc 'ls tests' in /Users/leemoore/code/v/codex-port succeeded in 16ms:
agent
agent-v2
client
client-v2
helpers
server
tools
tools-v2

thinking
**Checking existing agent-v2 files**
exec
/bin/zsh -lc 'ls tests/agent-v2' in /Users/leemoore/code/v/codex-port succeeded in 12ms:
prompt.test.ts
turn.test.ts

thinking
**Reviewing existing tests**
exec
/bin/zsh -lc "sed -n '1,160p' tests/agent-v2/prompt.test.ts" in /Users/leemoore/code/v/codex-port succeeded in 24ms:
import { describe, it, expect } from "bun:test";

describe("constructPromptV2", () => {
  it("placeholder - input array construction not implemented", () => {
    expect(() => {
      throw new Error("not implemented");
    }).toThrow("not implemented");
  });
});

thinking
**Checking test file**
exec
/bin/zsh -lc "sed -n '1,200p' tests/client-v2/responses.test.ts" in /Users/leemoore/code/v/codex-port succeeded in 25ms:
import { describe, it, expect } from "bun:test";

describe("ResponsesClientV2", () => {
  it("placeholder - SSE parsing not implemented", () => {
    expect(() => {
      throw new Error("not implemented");
    }).toThrow("not implemented");
  });
});

thinking
**Planning multi-step test and typesport**
Plan update
  → Inspect existing v2 scaffolding and determine required files/tests to port first
  • Port initial SSE parsing tests from Rust client.rs into Bun tests (failing state)
  • Create protocol types stub aligning with ResponseItem structure to satisfy tests later

thinking
**Inspecting source directory structure**
exec
/bin/zsh -lc 'ls src' in /Users/leemoore/code/v/codex-port succeeded in 23ms:
agent
client
prompts
server.ts
tools
types.ts

thinking
**Verifying agent-v2 presence and planning steps**
Plan update
  ✓ Inspect existing v2 scaffolding and determine required files/tests to port first
  • Port initial SSE parsing tests from Rust client.rs into Bun tests (failing state)
  • Create protocol types stub aligning with ResponseItem structure to satisfy tests later

thinking
**Preparing to port SSE parsing tests**
exec
/bin/zsh -lc "sed -n '1,160p' ../codex/codex-rs/core/tests/suite/client.rs" in /Users/leemoore/code/v/codex-port succeeded in 20ms:
use codex_app_server_protocol::AuthMode;
use codex_core::CodexAuth;
use codex_core::ContentItem;
use codex_core::ConversationManager;
use codex_core::LocalShellAction;
use codex_core::LocalShellExecAction;
use codex_core::LocalShellStatus;
use codex_core::ModelClient;
use codex_core::ModelProviderInfo;
use codex_core::NewConversation;
use codex_core::Prompt;
use codex_core::ReasoningItemContent;
use codex_core::ResponseEvent;
use codex_core::ResponseItem;
use codex_core::WireApi;
use codex_core::built_in_model_providers;
use codex_core::error::CodexErr;
use codex_core::model_family::find_family_for_model;
use codex_core::protocol::EventMsg;
use codex_core::protocol::Op;

thinking
**Searching for SSE test functions**
exec
/bin/zsh -lc 'rg "output_text" ../codex/codex-rs/core/tests/suite/client.rs' in /Users/leemoore/code/v/codex-port succeeded in 32ms:
            "content": [{ "type": "output_text", "text": "resumed assistant message" }]
        {"type":"response.output_text.delta", "delta":"Hey "},
        {"type":"response.output_text.delta", "delta":"there"},
        {"type":"response.output_text.delta", "delta":"!\n"},
            "content":[{"type":"output_text","text":"Hey there!\n"}]
            "content": [{"type":"output_text","text":"Hey there!\n"}]
            "content": [{"type":"output_text","text":"Hey there!\n"}]

thinking
**Expanding search context with line numbers**
exec
/bin/zsh -lc 'rg -n "response.output_text.delta" ../codex/codex-rs/core/tests/suite/client.rs' in /Users/leemoore/code/v/codex-port succeeded in 24ms:
1258:        {"type":"response.output_text.delta", "delta":"Hey "},
1259:        {"type":"response.output_text.delta", "delta":"there"},
1260:        {"type":"response.output_text.delta", "delta":"!\n"},

thinking
**Checking for tests near line 1200**
exec
/bin/zsh -lc "sed -n '1200,1320p' ../codex/codex-rs/core/tests/suite/client.rs" in /Users/leemoore/code/v/codex-port succeeded in 14ms:
        wire_api: WireApi::Responses,
        http_headers: Some(std::collections::HashMap::from([(
            "Custom-Header".to_string(),
            "Value".to_string(),
        )])),
        env_http_headers: None,
        request_max_retries: None,
        stream_max_retries: None,
        stream_idle_timeout_ms: None,
        requires_openai_auth: false,
    };

    // Init session
    let codex_home = TempDir::new().unwrap();
    let mut config = load_default_config_for_test(&codex_home);
    config.model_provider = provider;

    let conversation_manager = ConversationManager::with_auth(create_dummy_codex_auth());
    let codex = conversation_manager
        .new_conversation(config)

thinking
**Starting SSE parsing tests**
exec
/bin/zsh -lc "sed -n '1,200p' src/client/responses.ts" in /Users/leemoore/code/v/codex-port succeeded in 9ms:
import { loadAuthInfo, type AuthInfo } from "./auth";
import {
  AssistantMessageItem,
  ResponsesRequest,
  StreamItem,
  TokenUsage,
  ToolUseItem,
} from "./types";

interface UsageRef {
  current: TokenUsage | null;
}

export interface ResponsesClientOptions {
  baseUrl?: string;
  fetchImpl?: typeof fetch;
  tokenProvider?: () => Promise<string>;
  authProvider?: () => Promise<AuthInfo>;
  timeoutMs?: number;
}

thinking
**Preparing v2 client test strategy**
exec
/bin/zsh -lc 'ls src/client-v2' in /Users/leemoore/code/v/codex-port exited 1 in 11ms:
ls: src/client-v2: No such file or directory

thinking
**Checking test fixtures for SSE**
exec
/bin/zsh -lc 'ls tests/helpers' in /Users/leemoore/code/v/codex-port succeeded in 9ms:
assertions.ts
fixtures.ts

thinking
**Checking fixtures.ts**
exec
/bin/zsh -lc "sed -n '1,200p' tests/helpers/fixtures.ts" in /Users/leemoore/code/v/codex-port succeeded in 10ms:
import { join } from "node:path";
import { tmpdir } from "node:os";
import {
  mkdtemp as mkdtempAsync,
  mkdir as mkdirAsync,
  rm as rmAsync,
  writeFile as writeFileAsync,
} from "node:fs/promises";

const trackedTempDirs = new Set<string>();
const TEMP_DIR_PREFIX = "codex-port-";

export async function createTempDir(prefix = TEMP_DIR_PREFIX): Promise<string> {
  const dir = await mkdtempAsync(join(tmpdir(), prefix));
  trackedTempDirs.add(dir);
  return dir;
}

export async function createTempFile(
  dir: string,

thinking
**Checking for SSE fixture setup**
exec
/bin/zsh -lc "sed -n '1,200p' tests/helpers/assertions.ts" in /Users/leemoore/code/v/codex-port succeeded in 31ms:
import { expect } from "bun:test";

export async function expectErrorMessage<T>(
  promise: Promise<T>,
  message: string | RegExp,
): Promise<void> {
  await expect(promise).rejects.toThrow(message);
}

thinking
**Checking for SSE helper in tests**
exec
/bin/zsh -lc "sed -n '1,200p' tests/client/responses.test.ts" in /Users/leemoore/code/v/codex-port succeeded in 27ms:
import { describe, expect, it } from "bun:test";
import { ResponsesClient } from "../../src/client/responses";
import { ResponsesRequest } from "../../src/client/types";

type AuthDetails = {
  token: string;
  accountId?: string;
};

function buildSse(events: string[]): ReadableStream<Uint8Array> {
  const text = events.join("") + "\n";
  const encoder = new TextEncoder();
  return new ReadableStream({
    start(controller) {
      controller.enqueue(encoder.encode(text));
      controller.close();
    },
  });
}


thinking
**Preparing SSE tests and type scaffolding**

I'm mapping out how to port foundational SSE parsing tests from Rust into TypeScript, focusing on creating the minimal protocol types file and stub modules so tests compile but fail properly due to unimplemented logic. I plan to structure new directories and files, referencing Rust's `ResponseItem` to guide type definitions while ensuring tests reflect real expected behavior but fail initially, matching the test-first approach.
exec
/bin/zsh -lc 'rg -n "pub enum ResponseItem" ../codex/codex-rs -n' in /Users/leemoore/code/v/codex-port succeeded in 55ms:
../codex/codex-rs/protocol/src/models.rs:45:pub enum ResponseItem {
exec
/bin/zsh -lc "sed -n '45,200p' ../codex/codex-rs/protocol/src/models.rs" in /Users/leemoore/code/v/codex-port succeeded in 15ms:
pub enum ResponseItem {
    Message {
        #[serde(skip_serializing)]
        id: Option<String>,
        role: String,
        content: Vec<ContentItem>,
    },
    Reasoning {
        #[serde(default, skip_serializing)]
        id: String,
        summary: Vec<ReasoningItemReasoningSummary>,
        #[serde(default, skip_serializing_if = "should_serialize_reasoning_content")]
        content: Option<Vec<ReasoningItemContent>>,
        encrypted_content: Option<String>,
    },
    LocalShellCall {
        /// Set when using the chat completions API.
        #[serde(skip_serializing)]
        id: Option<String>,
        /// Set when using the Responses API.

thinking
**Continuing to locate FunctionCallOutputPayload definitions**
exec
/bin/zsh -lc 'rg -n "struct FunctionCallOutputPayload" ../codex/codex-rs/protocol/src/models.rs' in /Users/leemoore/code/v/codex-port succeeded in 28ms:
261:pub struct FunctionCallOutputPayload {
exec
/bin/zsh -lc "sed -n '200,320p' ../codex/codex-rs/protocol/src/models.rs" in /Users/leemoore/code/v/codex-port succeeded in 20ms:
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, JsonSchema, TS)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ReasoningItemContent {
    ReasoningText { text: String },
    Text { text: String },
}

impl From<Vec<UserInput>> for ResponseInputItem {
    fn from(items: Vec<UserInput>) -> Self {
        Self::Message {
            role: "user".to_string(),
            content: items
                .into_iter()
                .filter_map(|c| match c {
                    UserInput::Text { text } => Some(ContentItem::InputText { text }),
                    UserInput::Image { image_url } => Some(ContentItem::InputImage { image_url }),
                    UserInput::LocalImage { path } => match std::fs::read(&path) {
                        Ok(bytes) => {

thinking
**Planning SSE parsing tests**
exec
/bin/zsh -lc "sed -n '1,200p' docs/turn-tool-refactor.md" in /Users/leemoore/code/v/codex-port exited 1 in 22ms:
sed: docs/turn-tool-refactor.md: No such file or directory

thinking
**Investigating missing documentation and SSE event handling**
exec
/bin/zsh -lc 'rg -n "output_item" src/client/responses.ts' in /Users/leemoore/code/v/codex-port succeeded in 29ms:
577:  if (event === "response.output_item.done" && parsed && typeof parsed === "object") {
exec
/bin/zsh -lc "sed -n '520,640p' src/client/responses.ts" in /Users/leemoore/code/v/codex-port succeeded in 21ms:
        yield yielded;
      }
    }
  }

}

function updateResponseState(event: string | null, parsed: any, stateRef: ResponseStateRef): void {
  if (!event) {
    return;
  }

  if (parsed && typeof parsed === "object") {
    const response = parsed.response;
    if (response && typeof response === "object" && typeof response.id === "string") {
      stateRef.responseId = response.id;
      return;
    }

    if (event === "response.created" && typeof parsed.id === "string") {

thinking
**Planning new SSE event tests**
exec
/bin/zsh -lc 'rg -n "response.output" ../codex/codex-rs/core/src/client.rs' in /Users/leemoore/code/v/codex-port succeeded in 29ms:
775:            "response.output_item.done" => {
787:            "response.output_text.delta" => {
864:            | "response.custom_tool_call_input.done" // also emitted as response.output_item.done
866:            | "response.output_text.done" => {}
867:            "response.output_item.added" => {
1062:            "type": "response.output_item.done",
1072:            "type": "response.output_item.done",
1087:        let sse1 = format!("event: response.output_item.done\ndata: {item1}\n\n");
1088:        let sse2 = format!("event: response.output_item.done\ndata: {item2}\n\n");
1144:            "type": "response.output_item.done",
1153:        let sse1 = format!("event: response.output_item.done\ndata: {item1}\n\n");
1341:                    "type": "response.output_item.done",

thinking
**Inspecting around line 775**
exec
/bin/zsh -lc "sed -n '720,860p' ../codex/codex-rs/core/src/client.rs" in /Users/leemoore/code/v/codex-port succeeded in 21ms:
                        let _ = tx_event.send(Ok(event)).await;
                    }
                    None => {
                        let error = response_error.unwrap_or(CodexErr::Stream(
                            "stream closed before response.completed".into(),
                            None,
                        ));
                        otel_event_manager.see_event_completed_failed(&error);

                        let _ = tx_event.send(Err(error)).await;
                    }
                }
                return;
            }
            Err(_) => {
                let _ = tx_event
                    .send(Err(CodexErr::Stream(
                        "idle timeout waiting for SSE".into(),
                        None,
                    )))

thinking
**Reviewing event enumerations and related tests**
exec
/bin/zsh -lc "sed -n '1040,1160p' ../codex/codex-rs/core/src/client.rs" in /Users/leemoore/code/v/codex-port succeeded in 23ms:
    }

    fn otel_event_manager() -> OtelEventManager {
        OtelEventManager::new(
            ConversationId::new(),
            "test",
            "test",
            None,
            Some("test@test.com".to_string()),
            Some(AuthMode::ChatGPT),
            false,
            "test".to_string(),
        )
    }

    // ────────────────────────────
    // Tests from `implement-test-for-responses-api-sse-parser`
    // ────────────────────────────

    #[tokio::test]

thinking
**Identifying failing test**
exec
/bin/zsh -lc "sed -n '1160,1280p' ../codex/codex-rs/core/src/client.rs" in /Users/leemoore/code/v/codex-port succeeded in 13ms:
            query_params: None,
            http_headers: None,
            env_http_headers: None,
            request_max_retries: Some(0),
            stream_max_retries: Some(0),
            stream_idle_timeout_ms: Some(1000),
            requires_openai_auth: false,
        };

        let otel_event_manager = otel_event_manager();

        let events = collect_events(&[sse1.as_bytes()], provider, otel_event_manager).await;

        assert_eq!(events.len(), 2);

        matches!(events[0], Ok(ResponseEvent::OutputItemDone(_)));

        match &events[1] {
            Err(CodexErr::Stream(msg, _)) => {
                assert_eq!(msg, "stream closed before response.completed")

thinking
**Outlining SSE test port and types**

I'm planning how to port a couple of basic SSE parsing tests to TypeScript, focusing on `parses_items_and_completed` and `error_when_missing_completed`. I’m mapping out the needed TypeScript types like `ResponseEvent` and `ResponseItem`, considering how to stub or implement a minimal `ResponsesClientV2` or related parsing functions to keep the tests meaningful as they start failing for the right reasons. I’m also deciding on module structure and helper functions to mimic SSE streams in tests.
exec
/bin/zsh -lc "sed -n '1,200p' src/client/types.ts" in /Users/leemoore/code/v/codex-port succeeded in 9ms:
export interface ResponsesContentPart {
  type: string;
  text?: string;
  [key: string]: unknown;
}

export interface ResponsesMessage {
  id?: string;
  role: string;
  content: ResponsesContentPart[];
  tool_call_id?: string;
}

export interface ResponsesFunctionTool {
  type: "function";
  name: string;
  description?: string;
  strict?: boolean;
  parameters: Record<string, unknown>;
}

thinking
**Examining ResponseEvent enum**
exec
/bin/zsh -lc 'rg -n "pub enum ResponseEvent" ../codex/codex-rs' in /Users/leemoore/code/v/codex-port succeeded in 71ms:
../codex/codex-rs/core/src/client_common.rs:192:pub enum ResponseEvent {
exec
/bin/zsh -lc "sed -n '192,260p' ../codex/codex-rs/core/src/client_common.rs" in /Users/leemoore/code/v/codex-port succeeded in 16ms:
pub enum ResponseEvent {
    Created,
    OutputItemDone(ResponseItem),
    Completed {
        response_id: String,
        token_usage: Option<TokenUsage>,
    },
    OutputTextDelta(String),
    ReasoningSummaryDelta(String),
    ReasoningContentDelta(String),
    ReasoningSummaryPartAdded,
    WebSearchCallBegin {
        call_id: String,
    },
    RateLimits(RateLimitSnapshot),
}

#[derive(Debug, Serialize)]
pub(crate) struct Reasoning {
    #[serde(skip_serializing_if = "Option::is_none")]

thinking
**Designing TypeScript response event types and test scaffolding**

I’m mapping out TypeScript types to mirror Rust’s response events and planning test helpers to simulate event streams. I’m setting up stub functions and async generators that throw or yield empty results so tests will initially fail for the right reasons. I also want to organize new type definitions and parsing logic in fresh directories to keep everything clean and align with future implementations. This foundation will help ensure the tests guide the actual parser development later.
exec
/bin/zsh -lc 'mkdir -p src/protocol src/client-v2' in /Users/leemoore/code/v/codex-port succeeded in 21ms:


thinking
**Defining response types in new file**
file update
A /Users/leemoore/code/v/codex-port/src/protocol/types.ts
export interface TokenUsage {
  input_tokens: number;
  input_tokens_details?: unknown;
  output_tokens: number;
  output_tokens_details?: unknown;
  total_tokens: number;
}

export interface OutputTextContent {
  type: "output_text" | "text";
  text: string;
}

export interface InputTextContent {
  type: "input_text";
  text: string;
}

export interface OutputImageContent {
  type: "output_image";
  image_url: string;
  alt_text?: string | null;
}

export interface InputImageContent {
  type: "input_image";
  image_url: string;
}

export interface ReasoningTextContent {
  type: "reasoning_text";
  text: string;
}

export interface ReasoningSummaryTextContent {
  type: "summary_text";
  text: string;
}

export type ResponseContentItem =
  | OutputTextContent
  | InputTextContent
  | OutputImageContent
  | InputImageContent
  | ReasoningTextContent
  | ReasoningSummaryTextContent
  | { type: string; [key: string]: unknown };

export interface ResponseMessageItem {
  type: "message";
  role: string;
  content: ResponseContentItem[];
  id?: string;
  name?: string;
  call_id?: string;
}

export interface ReasoningSummary {
  type: "summary_text";
  text: string;
}

export interface ReasoningContent {
  type: "reasoning_text" | "text";
  text: string;
}

export interface ResponseReasoningItem {
  type: "reasoning";
  id?: string;
  summary: ReasoningSummary[];
  content?: ReasoningContent[];
  encrypted_content?: string | null;
}

export interface LocalShellStatusBase {
  type: "local_shell_call";
  id?: string;
  call_id?: string;
  status: "completed" | "in_progress" | "incomplete";
}

export interface LocalShellExecAction {
  type: "exec";
  command: string[];
  timeout_ms?: number | null;
  working_directory?: string | null;
  env?: Record<string, string>;
  user?: string | null;
}

export interface ResponseLocalShellCallItem extends LocalShellStatusBase {
  action: LocalShellExecAction | { type: string; [key: string]: unknown };
}

export interface ResponseFunctionCallItem {
  type: "function_call";
  id?: string;
  name: string;
  arguments: string;
  call_id: string;
}

export interface FunctionCallOutputPayload {
  content: string;
  success?: boolean;
}

export interface ResponseFunctionCallOutputItem {
  type: "function_call_output";
  call_id: string;
  output: FunctionCallOutputPayload;
}

export interface ResponseCustomToolCallItem {
  type: "custom_tool_call";
  id?: string;
  status?: string;
  call_id: string;
  name: string;
  input: string;
}

export interface ResponseCustomToolCallOutputItem {
  type: "custom_tool_call_output";
  call_id: string;
  output: string;
}

export interface ResponseWebSearchCallItem {
  type: "web_search_call";
  id?: string;
  status?: string;
  action: {
    type: string;
    query?: string;
    [key: string]: unknown;
  };
}

export interface ResponseOtherItem {
  type: string;
  [key: string]: unknown;
}

export type ResponseItem =
  | ResponseMessageItem
  | ResponseReasoningItem
  | ResponseLocalShellCallItem
  | ResponseFunctionCallItem
  | ResponseFunctionCallOutputItem
  | ResponseCustomToolCallItem
  | ResponseCustomToolCallOutputItem
  | ResponseWebSearchCallItem
  | ResponseOtherItem;

export type ResponseEvent =
  | { type: "created" }
  | { type: "output_item.done"; item: ResponseItem }
  | { type: "completed"; responseId: string; tokenUsage: TokenUsage | null }
  | { type: "output_text.delta"; delta: string }
  | { type: "reasoning_summary.delta"; delta: string }
  | { type: "reasoning_content.delta"; delta: string }
  | { type: "reasoning_summary.part_added" }
  | { type: "web_search_call.begin"; callId: string }
  | { type: "rate_limits"; snapshot: unknown };
apply_patch(auto_approved=true) exited 0 in 13ms:
Success. Updated the following files:
A src/protocol/types.ts
file update:
diff --git a/src/protocol/types.ts b/src/protocol/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..00a6201cdf312e18c2e8cf3991c774d3e420d289
--- /dev/null
+++ b/src/protocol/types.ts
@@ -0,0 +1,166 @@
+export interface TokenUsage {
+  input_tokens: number;
+  input_tokens_details?: unknown;
+  output_tokens: number;
+  output_tokens_details?: unknown;
+  total_tokens: number;
+}
+
+export interface OutputTextContent {
+  type: "output_text" | "text";
+  text: string;
+}
+
+export interface InputTextContent {
+  type: "input_text";
+  text: string;
+}
+
+export interface OutputImageContent {
+  type: "output_image";
+  image_url: string;
+  alt_text?: string | null;
+}
+
+export interface InputImageContent {
+  type: "input_image";
+  image_url: string;
+}
+
+export interface ReasoningTextContent {
+  type: "reasoning_text";
+  text: string;
+}
+
+export interface ReasoningSummaryTextContent {
+  type: "summary_text";
+  text: string;
+}
+
+export type ResponseContentItem =
+  | OutputTextContent
+  | InputTextContent
+  | OutputImageContent
+  | InputImageContent
+  | ReasoningTextContent
+  | ReasoningSummaryTextContent
+  | { type: string; [key: string]: unknown };
+
+export interface ResponseMessageItem {
+  type: "message";
+  role: string;
+  content: ResponseContentItem[];
+  id?: string;
+  name?: string;
+  call_id?: string;
+}
+
+export interface ReasoningSummary {
+  type: "summary_text";
+  text: string;
+}
+
+export interface ReasoningContent {
+  type: "reasoning_text" | "text";
+  text: string;
+}
+
+export interface ResponseReasoningItem {
+  type: "reasoning";
+  id?: string;
+  summary: ReasoningSummary[];
+  content?: ReasoningContent[];
+  encrypted_content?: string | null;
+}
+
+export interface LocalShellStatusBase {
+  type: "local_shell_call";
+  id?: string;
+  call_id?: string;
+  status: "completed" | "in_progress" | "incomplete";
+}
+
+export interface LocalShellExecAction {
+  type: "exec";
+  command: string[];
+  timeout_ms?: number | null;
+  working_directory?: string | null;
+  env?: Record<string, string>;
+  user?: string | null;
+}
+
+export interface ResponseLocalShellCallItem extends LocalShellStatusBase {
+  action: LocalShellExecAction | { type: string; [key: string]: unknown };
+}
+
+export interface ResponseFunctionCallItem {
+  type: "function_call";
+  id?: string;
+  name: string;
+  arguments: string;
+  call_id: string;
+}
+
+export interface FunctionCallOutputPayload {
+  content: string;
+  success?: boolean;
+}
+
+export interface ResponseFunctionCallOutputItem {
+  type: "function_call_output";
+  call_id: string;
+  output: FunctionCallOutputPayload;
+}
+
+export interface ResponseCustomToolCallItem {
+  type: "custom_tool_call";
+  id?: string;
+  status?: string;
+  call_id: string;
+  name: string;
+  input: string;
+}
+
+export interface ResponseCustomToolCallOutputItem {
+  type: "custom_tool_call_output";
+  call_id: string;
+  output: string;
+}
+
+export interface ResponseWebSearchCallItem {
+  type: "web_search_call";
+  id?: string;
+  status?: string;
+  action: {
+    type: string;
+    query?: string;
+    [key: string]: unknown;
+  };
+}
+
+export interface ResponseOtherItem {
+  type: string;
+  [key: string]: unknown;
+}
+
+export type ResponseItem =
+  | ResponseMessageItem
+  | ResponseReasoningItem
+  | ResponseLocalShellCallItem
+  | ResponseFunctionCallItem
+  | ResponseFunctionCallOutputItem
+  | ResponseCustomToolCallItem
+  | ResponseCustomToolCallOutputItem
+  | ResponseWebSearchCallItem
+  | ResponseOtherItem;
+
+export type ResponseEvent =
+  | { type: "created" }
+  | { type: "output_item.done"; item: ResponseItem }
+  | { type: "completed"; responseId: string; tokenUsage: TokenUsage | null }
+  | { type: "output_text.delta"; delta: string }
+  | { type: "reasoning_summary.delta"; delta: string }
+  | { type: "reasoning_content.delta"; delta: string }
+  | { type: "reasoning_summary.part_added" }
+  | { type: "web_search_call.begin"; callId: string }
+  | { type: "rate_limits"; snapshot: unknown };

file update:
diff --git a/src/protocol/types.ts b/src/protocol/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..00a6201cdf312e18c2e8cf3991c774d3e420d289
--- /dev/null
+++ b/src/protocol/types.ts
@@ -0,0 +1,166 @@
+export interface TokenUsage {
+  input_tokens: number;
+  input_tokens_details?: unknown;
+  output_tokens: number;
+  output_tokens_details?: unknown;
+  total_tokens: number;
+}
+
+export interface OutputTextContent {
+  type: "output_text" | "text";
+  text: string;
+}
+
+export interface InputTextContent {
+  type: "input_text";
+  text: string;
+}
+
+export interface OutputImageContent {
+  type: "output_image";
+  image_url: string;
+  alt_text?: string | null;
+}
+
+export interface InputImageContent {
+  type: "input_image";
+  image_url: string;
+}
+
+export interface ReasoningTextContent {
+  type: "reasoning_text";
+  text: string;
+}
+
+export interface ReasoningSummaryTextContent {
+  type: "summary_text";
+  text: string;
+}
+
+export type ResponseContentItem =
+  | OutputTextContent
+  | InputTextContent
+  | OutputImageContent
+  | InputImageContent
+  | ReasoningTextContent
+  | ReasoningSummaryTextContent
+  | { type: string; [key: string]: unknown };
+
+export interface ResponseMessageItem {
+  type: "message";
+  role: string;
+  content: ResponseContentItem[];
+  id?: string;
+  name?: string;
+  call_id?: string;
+}
+
+export interface ReasoningSummary {
+  type: "summary_text";
+  text: string;
+}
+
+export interface ReasoningContent {
+  type: "reasoning_text" | "text";
+  text: string;
+}
+
+export interface ResponseReasoningItem {
+  type: "reasoning";
+  id?: string;
+  summary: ReasoningSummary[];
+  content?: ReasoningContent[];
+  encrypted_content?: string | null;
+}
+
+export interface LocalShellStatusBase {
+  type: "local_shell_call";
+  id?: string;
+  call_id?: string;
+  status: "completed" | "in_progress" | "incomplete";
+}
+
+export interface LocalShellExecAction {
+  type: "exec";
+  command: string[];
+  timeout_ms?: number | null;
+  working_directory?: string | null;
+  env?: Record<string, string>;
+  user?: string | null;
+}
+
+export interface ResponseLocalShellCallItem extends LocalShellStatusBase {
+  action: LocalShellExecAction | { type: string; [key: string]: unknown };
+}
+
+export interface ResponseFunctionCallItem {
+  type: "function_call";
+  id?: string;
+  name: string;
+  arguments: string;
+  call_id: string;
+}
+
+export interface FunctionCallOutputPayload {
+  content: string;
+  success?: boolean;
+}
+
+export interface ResponseFunctionCallOutputItem {
+  type: "function_call_output";
+  call_id: string;
+  output: FunctionCallOutputPayload;
+}
+
+export interface ResponseCustomToolCallItem {
+  type: "custom_tool_call";
+  id?: string;
+  status?: string;
+  call_id: string;
+  name: string;
+  input: string;
+}
+
+export interface ResponseCustomToolCallOutputItem {
+  type: "custom_tool_call_output";
+  call_id: string;
+  output: string;
+}
+
+export interface ResponseWebSearchCallItem {
+  type: "web_search_call";
+  id?: string;
+  status?: string;
+  action: {
+    type: string;
+    query?: string;
+    [key: string]: unknown;
+  };
+}
+
+export interface ResponseOtherItem {
+  type: string;
+  [key: string]: unknown;
+}
+
+export type ResponseItem =
+  | ResponseMessageItem
+  | ResponseReasoningItem
+  | ResponseLocalShellCallItem
+  | ResponseFunctionCallItem
+  | ResponseFunctionCallOutputItem
+  | ResponseCustomToolCallItem
+  | ResponseCustomToolCallOutputItem
+  | ResponseWebSearchCallItem
+  | ResponseOtherItem;
+
+export type ResponseEvent =
+  | { type: "created" }
+  | { type: "output_item.done"; item: ResponseItem }
+  | { type: "completed"; responseId: string; tokenUsage: TokenUsage | null }
+  | { type: "output_text.delta"; delta: string }
+  | { type: "reasoning_summary.delta"; delta: string }
+  | { type: "reasoning_content.delta"; delta: string }
+  | { type: "reasoning_summary.part_added" }
+  | { type: "web_search_call.begin"; callId: string }
+  | { type: "rate_limits"; snapshot: unknown };


thinking
**Reviewing event type naming and preparing test updates**
file update
A /Users/leemoore/code/v/codex-port/src/client-v2/responses.ts
import type { ResponseEvent } from "../protocol/types";

/**
 * Temporary stub for the v2 Responses client stream parser.
 *
 * The real implementation will mirror the Rust SSE parser, yielding
 * {@link ResponseEvent} objects as the OpenAI Responses API emits data.
 */
export function parseResponsesStream(
  stream: ReadableStream<Uint8Array>,
): AsyncGenerator<ResponseEvent, void, unknown> {
  void stream;

  return (async function* (): AsyncGenerator<ResponseEvent, void, unknown> {
    // The initial implementation intentionally yields nothing so that the
    // accompanying tests fail until the real parser is ported.
    return;
  })();
}
apply_patch(auto_approved=true) exited 0 in 16ms:
Success. Updated the following files:
A src/client-v2/responses.ts
file update:
diff --git a/src/client-v2/responses.ts b/src/client-v2/responses.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ef91b7388e0669b55a868e803390209c77adf2b9
--- /dev/null
+++ b/src/client-v2/responses.ts
@@ -0,0 +1,19 @@
+import type { ResponseEvent } from "../protocol/types";
+
+/**
+ * Temporary stub for the v2 Responses client stream parser.
+ *
+ * The real implementation will mirror the Rust SSE parser, yielding
+ * {@link ResponseEvent} objects as the OpenAI Responses API emits data.
+ */
+export function parseResponsesStream(
+  stream: ReadableStream<Uint8Array>,
+): AsyncGenerator<ResponseEvent, void, unknown> {
+  void stream;
+
+  return (async function* (): AsyncGenerator<ResponseEvent, void, unknown> {
+    // The initial implementation intentionally yields nothing so that the
+    // accompanying tests fail until the real parser is ported.
+    return;
+  })();
+}
diff --git a/src/protocol/types.ts b/src/protocol/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..00a6201cdf312e18c2e8cf3991c774d3e420d289
--- /dev/null
+++ b/src/protocol/types.ts
@@ -0,0 +1,166 @@
+export interface TokenUsage {
+  input_tokens: number;
+  input_tokens_details?: unknown;
+  output_tokens: number;
+  output_tokens_details?: unknown;
+  total_tokens: number;
+}
+
+export interface OutputTextContent {
+  type: "output_text" | "text";
+  text: string;
+}
+
+export interface InputTextContent {
+  type: "input_text";
+  text: string;
+}
+
+export interface OutputImageContent {
+  type: "output_image";
+  image_url: string;
+  alt_text?: string | null;
+}
+
+export interface InputImageContent {
+  type: "input_image";
+  image_url: string;
+}
+
+export interface ReasoningTextContent {
+  type: "reasoning_text";
+  text: string;
+}
+
+export interface ReasoningSummaryTextContent {
+  type: "summary_text";
+  text: string;
+}
+
+export type ResponseContentItem =
+  | OutputTextContent
+  | InputTextContent
+  | OutputImageContent
+  | InputImageContent
+  | ReasoningTextContent
+  | ReasoningSummaryTextContent
+  | { type: string; [key: string]: unknown };
+
+export interface ResponseMessageItem {
+  type: "message";
+  role: string;
+  content: ResponseContentItem[];
+  id?: string;
+  name?: string;
+  call_id?: string;
+}
+
+export interface ReasoningSummary {
+  type: "summary_text";
+  text: string;
+}
+
+export interface ReasoningContent {
+  type: "reasoning_text" | "text";
+  text: string;
+}
+
+export interface ResponseReasoningItem {
+  type: "reasoning";
+  id?: string;
+  summary: ReasoningSummary[];
+  content?: ReasoningContent[];
+  encrypted_content?: string | null;
+}
+
+export interface LocalShellStatusBase {
+  type: "local_shell_call";
+  id?: string;
+  call_id?: string;
+  status: "completed" | "in_progress" | "incomplete";
+}
+
+export interface LocalShellExecAction {
+  type: "exec";
+  command: string[];
+  timeout_ms?: number | null;
+  working_directory?: string | null;
+  env?: Record<string, string>;
+  user?: string | null;
+}
+
+export interface ResponseLocalShellCallItem extends LocalShellStatusBase {
+  action: LocalShellExecAction | { type: string; [key: string]: unknown };
+}
+
+export interface ResponseFunctionCallItem {
+  type: "function_call";
+  id?: string;
+  name: string;
+  arguments: string;
+  call_id: string;
+}
+
+export interface FunctionCallOutputPayload {
+  content: string;
+  success?: boolean;
+}
+
+export interface ResponseFunctionCallOutputItem {
+  type: "function_call_output";
+  call_id: string;
+  output: FunctionCallOutputPayload;
+}
+
+export interface ResponseCustomToolCallItem {
+  type: "custom_tool_call";
+  id?: string;
+  status?: string;
+  call_id: string;
+  name: string;
+  input: string;
+}
+
+export interface ResponseCustomToolCallOutputItem {
+  type: "custom_tool_call_output";
+  call_id: string;
+  output: string;
+}
+
+export interface ResponseWebSearchCallItem {
+  type: "web_search_call";
+  id?: string;
+  status?: string;
+  action: {
+    type: string;
+    query?: string;
+    [key: string]: unknown;
+  };
+}
+
+export interface ResponseOtherItem {
+  type: string;
+  [key: string]: unknown;
+}
+
+export type ResponseItem =
+  | ResponseMessageItem
+  | ResponseReasoningItem
+  | ResponseLocalShellCallItem
+  | ResponseFunctionCallItem
+  | ResponseFunctionCallOutputItem
+  | ResponseCustomToolCallItem
+  | ResponseCustomToolCallOutputItem
+  | ResponseWebSearchCallItem
+  | ResponseOtherItem;
+
+export type ResponseEvent =
+  | { type: "created" }
+  | { type: "output_item.done"; item: ResponseItem }
+  | { type: "completed"; responseId: string; tokenUsage: TokenUsage | null }
+  | { type: "output_text.delta"; delta: string }
+  | { type: "reasoning_summary.delta"; delta: string }
+  | { type: "reasoning_content.delta"; delta: string }
+  | { type: "reasoning_summary.part_added" }
+  | { type: "web_search_call.begin"; callId: string }
+  | { type: "rate_limits"; snapshot: unknown };

file update:
diff --git a/src/client-v2/responses.ts b/src/client-v2/responses.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ef91b7388e0669b55a868e803390209c77adf2b9
--- /dev/null
+++ b/src/client-v2/responses.ts
@@ -0,0 +1,19 @@
+import type { ResponseEvent } from "../protocol/types";
+
+/**
+ * Temporary stub for the v2 Responses client stream parser.
+ *
+ * The real implementation will mirror the Rust SSE parser, yielding
+ * {@link ResponseEvent} objects as the OpenAI Responses API emits data.
+ */
+export function parseResponsesStream(
+  stream: ReadableStream<Uint8Array>,
+): AsyncGenerator<ResponseEvent, void, unknown> {
+  void stream;
+
+  return (async function* (): AsyncGenerator<ResponseEvent, void, unknown> {
+    // The initial implementation intentionally yields nothing so that the
+    // accompanying tests fail until the real parser is ported.
+    return;
+  })();
+}
diff --git a/src/protocol/types.ts b/src/protocol/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..00a6201cdf312e18c2e8cf3991c774d3e420d289
--- /dev/null
+++ b/src/protocol/types.ts
@@ -0,0 +1,166 @@
+export interface TokenUsage {
+  input_tokens: number;
+  input_tokens_details?: unknown;
+  output_tokens: number;
+  output_tokens_details?: unknown;
+  total_tokens: number;
+}
+
+export interface OutputTextContent {
+  type: "output_text" | "text";
+  text: string;
+}
+
+export interface InputTextContent {
+  type: "input_text";
+  text: string;
+}
+
+export interface OutputImageContent {
+  type: "output_image";
+  image_url: string;
+  alt_text?: string | null;
+}
+
+export interface InputImageContent {
+  type: "input_image";
+  image_url: string;
+}
+
+export interface ReasoningTextContent {
+  type: "reasoning_text";
+  text: string;
+}
+
+export interface ReasoningSummaryTextContent {
+  type: "summary_text";
+  text: string;
+}
+
+export type ResponseContentItem =
+  | OutputTextContent
+  | InputTextContent
+  | OutputImageContent
+  | InputImageContent
+  | ReasoningTextContent
+  | ReasoningSummaryTextContent
+  | { type: string; [key: string]: unknown };
+
+export interface ResponseMessageItem {
+  type: "message";
+  role: string;
+  content: ResponseContentItem[];
+  id?: string;
+  name?: string;
+  call_id?: string;
+}
+
+export interface ReasoningSummary {
+  type: "summary_text";
+  text: string;
+}
+
+export interface ReasoningContent {
+  type: "reasoning_text" | "text";
+  text: string;
+}
+
+export interface ResponseReasoningItem {
+  type: "reasoning";
+  id?: string;
+  summary: ReasoningSummary[];
+  content?: ReasoningContent[];
+  encrypted_content?: string | null;
+}
+
+export interface LocalShellStatusBase {
+  type: "local_shell_call";
+  id?: string;
+  call_id?: string;
+  status: "completed" | "in_progress" | "incomplete";
+}
+
+export interface LocalShellExecAction {
+  type: "exec";
+  command: string[];
+  timeout_ms?: number | null;
+  working_directory?: string | null;
+  env?: Record<string, string>;
+  user?: string | null;
+}
+
+export interface ResponseLocalShellCallItem extends LocalShellStatusBase {
+  action: LocalShellExecAction | { type: string; [key: string]: unknown };
+}
+
+export interface ResponseFunctionCallItem {
+  type: "function_call";
+  id?: string;
+  name: string;
+  arguments: string;
+  call_id: string;
+}
+
+export interface FunctionCallOutputPayload {
+  content: string;
+  success?: boolean;
+}
+
+export interface ResponseFunctionCallOutputItem {
+  type: "function_call_output";
+  call_id: string;
+  output: FunctionCallOutputPayload;
+}
+
+export interface ResponseCustomToolCallItem {
+  type: "custom_tool_call";
+  id?: string;
+  status?: string;
+  call_id: string;
+  name: string;
+  input: string;
+}
+
+export interface ResponseCustomToolCallOutputItem {
+  type: "custom_tool_call_output";
+  call_id: string;
+  output: string;
+}
+
+export interface ResponseWebSearchCallItem {
+  type: "web_search_call";
+  id?: string;
+  status?: string;
+  action: {
+    type: string;
+    query?: string;
+    [key: string]: unknown;
+  };
+}
+
+export interface ResponseOtherItem {
+  type: string;
+  [key: string]: unknown;
+}
+
+export type ResponseItem =
+  | ResponseMessageItem
+  | ResponseReasoningItem
+  | ResponseLocalShellCallItem
+  | ResponseFunctionCallItem
+  | ResponseFunctionCallOutputItem
+  | ResponseCustomToolCallItem
+  | ResponseCustomToolCallOutputItem
+  | ResponseWebSearchCallItem
+  | ResponseOtherItem;
+
+export type ResponseEvent =
+  | { type: "created" }
+  | { type: "output_item.done"; item: ResponseItem }
+  | { type: "completed"; responseId: string; tokenUsage: TokenUsage | null }
+  | { type: "output_text.delta"; delta: string }
+  | { type: "reasoning_summary.delta"; delta: string }
+  | { type: "reasoning_content.delta"; delta: string }
+  | { type: "reasoning_summary.part_added" }
+  | { type: "web_search_call.begin"; callId: string }
+  | { type: "rate_limits"; snapshot: unknown };


thinking
**Updating tests for new parser function**

I'll update the `responses.test.ts` file to replace placeholders and port tests similar to Rust. This involves crafting SSE event strings matching Rust’s format, implementing helper functions to build the stream, and writing tests that verify streamed events and error handling, especially for cases where the stream ends prematurely or completes correctly. I need to carefully design `collect` to aggregate events and catch errors so tests reflect the expected behaviors accurately.
file update
M /Users/leemoore/code/v/codex-port/tests/client-v2/responses.test.ts
@@ -1,8 +1,106 @@
-import { describe, it, expect } from "bun:test";
+import { describe, expect, it } from "bun:test";
+import { parseResponsesStream } from "../../src/client-v2/responses";
+import type { ResponseEvent } from "../../src/protocol/types";
+
+function buildSse(events: string[]): ReadableStream<Uint8Array> {
+  const encoder = new TextEncoder();
+  const payload = events.join("") + "\n";
+  return new ReadableStream({
+    start(controller) {
+      controller.enqueue(encoder.encode(payload));
+      controller.close();
+    },
+  });
+}
+
+function responseOutputItemDone(payload: unknown): string {
+  return `event: response.output_item.done\ndata: ${JSON.stringify(payload)}\n\n`;
+}
+
+function responseCompleted(payload: unknown): string {
+  return `event: response.completed\ndata: ${JSON.stringify(payload)}\n\n`;
+}
+
+async function collectEvents(stream: ReadableStream<Uint8Array>): Promise<{
+  events: ResponseEvent[];
+  error: Error | null;
+}> {
+  const events: ResponseEvent[] = [];
+  let error: Error | null = null;
+
+  try {
+    for await (const event of parseResponsesStream(stream)) {
+      events.push(event);
+    }
+  } catch (err) {
+    error = err as Error;
+  }
+
+  return { events, error };
+}
+
+describe("parseResponsesStream", () => {
+  it("parses output_item.done events and final completed envelope", async () => {
+    const sse = buildSse([
+      responseOutputItemDone({
+        type: "response.output_item.done",
+        item: {
+          type: "message",
+          role: "assistant",
+          content: [{ type: "output_text", text: "Hello" }],
+        },
+      }),
+      responseOutputItemDone({
+        type: "response.output_item.done",
+        item: {
+          type: "message",
+          role: "assistant",
+          content: [{ type: "output_text", text: "World" }],
+        },
+      }),
+      responseCompleted({
+        type: "response.completed",
+        response: { id: "resp1" },
+      }),
+    ]);
 
-describe("ResponsesClientV2", () => {
-  it("placeholder - SSE parsing not implemented", () => {
-    expect(() => {
-      throw new Error("not implemented");
-    }).toThrow("not implemented");
+    const { events, error } = await collectEvents(sse);
+
+    expect(error).toBeNull();
+    expect(events).toHaveLength(3);
+    expect(events[0]).toMatchObject({
+      type: "output_item.done",
+      item: { type: "message", role: "assistant" },
+    });
+    expect(events[1]).toMatchObject({
+      type: "output_item.done",
+      item: { type: "message", role: "assistant" },
+    });
+    expect(events[2]).toEqual({
+      type: "completed",
+      responseId: "resp1",
+      tokenUsage: null,
+    });
+  });
+
+  it("reports an error when response.completed is missing", async () => {
+    const sse = buildSse([
+      responseOutputItemDone({
+        type: "response.output_item.done",
+        item: {
+          type: "message",
+          role: "assistant",
+          content: [{ type: "output_text", text: "Hello" }],
+        },
+      }),
+    ]);
+
+    const { events, error } = await collectEvents(sse);
+
+    expect(events).toHaveLength(1);
+    expect(events[0]).toMatchObject({
+      type: "output_item.done",
+    });
+    expect(error).toBeInstanceOf(Error);
+    expect(error?.message).toBe("stream closed before response.completed");
   });
apply_patch(auto_approved=true) exited 0 in 21ms:
Success. Updated the following files:
M tests/client-v2/responses.test.ts
file update:
diff --git a/src/client-v2/responses.ts b/src/client-v2/responses.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ef91b7388e0669b55a868e803390209c77adf2b9
--- /dev/null
+++ b/src/client-v2/responses.ts
@@ -0,0 +1,19 @@
+import type { ResponseEvent } from "../protocol/types";
+
+/**
+ * Temporary stub for the v2 Responses client stream parser.
+ *
+ * The real implementation will mirror the Rust SSE parser, yielding
+ * {@link ResponseEvent} objects as the OpenAI Responses API emits data.
+ */
+export function parseResponsesStream(
+  stream: ReadableStream<Uint8Array>,
+): AsyncGenerator<ResponseEvent, void, unknown> {
+  void stream;
+
+  return (async function* (): AsyncGenerator<ResponseEvent, void, unknown> {
+    // The initial implementation intentionally yields nothing so that the
+    // accompanying tests fail until the real parser is ported.
+    return;
+  })();
+}
diff --git a/src/protocol/types.ts b/src/protocol/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..00a6201cdf312e18c2e8cf3991c774d3e420d289
--- /dev/null
+++ b/src/protocol/types.ts
@@ -0,0 +1,166 @@
+export interface TokenUsage {
+  input_tokens: number;
+  input_tokens_details?: unknown;
+  output_tokens: number;
+  output_tokens_details?: unknown;
+  total_tokens: number;
+}
+
+export interface OutputTextContent {
+  type: "output_text" | "text";
+  text: string;
+}
+
+export interface InputTextContent {
+  type: "input_text";
+  text: string;
+}
+
+export interface OutputImageContent {
+  type: "output_image";
+  image_url: string;
+  alt_text?: string | null;
+}
+
+export interface InputImageContent {
+  type: "input_image";
+  image_url: string;
+}
+
+export interface ReasoningTextContent {
+  type: "reasoning_text";
+  text: string;
+}
+
+export interface ReasoningSummaryTextContent {
+  type: "summary_text";
+  text: string;
+}
+
+export type ResponseContentItem =
+  | OutputTextContent
+  | InputTextContent
+  | OutputImageContent
+  | InputImageContent
+  | ReasoningTextContent
+  | ReasoningSummaryTextContent
+  | { type: string; [key: string]: unknown };
+
+export interface ResponseMessageItem {
+  type: "message";
+  role: string;
+  content: ResponseContentItem[];
+  id?: string;
+  name?: string;
+  call_id?: string;
+}
+
+export interface ReasoningSummary {
+  type: "summary_text";
+  text: string;
+}
+
+export interface ReasoningContent {
+  type: "reasoning_text" | "text";
+  text: string;
+}
+
+export interface ResponseReasoningItem {
+  type: "reasoning";
+  id?: string;
+  summary: ReasoningSummary[];
+  content?: ReasoningContent[];
+  encrypted_content?: string | null;
+}
+
+export interface LocalShellStatusBase {
+  type: "local_shell_call";
+  id?: string;
+  call_id?: string;
+  status: "completed" | "in_progress" | "incomplete";
+}
+
+export interface LocalShellExecAction {
+  type: "exec";
+  command: string[];
+  timeout_ms?: number | null;
+  working_directory?: string | null;
+  env?: Record<string, string>;
+  user?: string | null;
+}
+
+export interface ResponseLocalShellCallItem extends LocalShellStatusBase {
+  action: LocalShellExecAction | { type: string; [key: string]: unknown };
+}
+
+export interface ResponseFunctionCallItem {
+  type: "function_call";
+  id?: string;
+  name: string;
+  arguments: string;
+  call_id: string;
+}
+
+export interface FunctionCallOutputPayload {
+  content: string;
+  success?: boolean;
+}
+
+export interface ResponseFunctionCallOutputItem {
+  type: "function_call_output";
+  call_id: string;
+  output: FunctionCallOutputPayload;
+}
+
+export interface ResponseCustomToolCallItem {
+  type: "custom_tool_call";
+  id?: string;
+  status?: string;
+  call_id: string;
+  name: string;
+  input: string;
+}
+
+export interface ResponseCustomToolCallOutputItem {
+  type: "custom_tool_call_output";
+  call_id: string;
+  output: string;
+}
+
+export interface ResponseWebSearchCallItem {
+  type: "web_search_call";
+  id?: string;
+  status?: string;
+  action: {
+    type: string;
+    query?: string;
+    [key: string]: unknown;
+  };
+}
+
+export interface ResponseOtherItem {
+  type: string;
+  [key: string]: unknown;
+}
+
+export type ResponseItem =
+  | ResponseMessageItem
+  | ResponseReasoningItem
+  | ResponseLocalShellCallItem
+  | ResponseFunctionCallItem
+  | ResponseFunctionCallOutputItem
+  | ResponseCustomToolCallItem
+  | ResponseCustomToolCallOutputItem
+  | ResponseWebSearchCallItem
+  | ResponseOtherItem;
+
+export type ResponseEvent =
+  | { type: "created" }
+  | { type: "output_item.done"; item: ResponseItem }
+  | { type: "completed"; responseId: string; tokenUsage: TokenUsage | null }
+  | { type: "output_text.delta"; delta: string }
+  | { type: "reasoning_summary.delta"; delta: string }
+  | { type: "reasoning_content.delta"; delta: string }
+  | { type: "reasoning_summary.part_added" }
+  | { type: "web_search_call.begin"; callId: string }
+  | { type: "rate_limits"; snapshot: unknown };
diff --git a/tests/client-v2/responses.test.ts b/tests/client-v2/responses.test.ts
index 31dce545da2598505e9b0bbbff3fbcd1619905e3..c4b649112ba5027424a59260197c5cc9b4ff0211
--- a/tests/client-v2/responses.test.ts
+++ b/tests/client-v2/responses.test.ts
@@ -1,9 +1,107 @@
-import { describe, it, expect } from "bun:test";
+import { describe, expect, it } from "bun:test";
+import { parseResponsesStream } from "../../src/client-v2/responses";
+import type { ResponseEvent } from "../../src/protocol/types";
+
+function buildSse(events: string[]): ReadableStream<Uint8Array> {
+  const encoder = new TextEncoder();
+  const payload = events.join("") + "\n";
+  return new ReadableStream({
+    start(controller) {
+      controller.enqueue(encoder.encode(payload));
+      controller.close();
+    },
+  });
+}
+
+function responseOutputItemDone(payload: unknown): string {
+  return `event: response.output_item.done\ndata: ${JSON.stringify(payload)}\n\n`;
+}
+
+function responseCompleted(payload: unknown): string {
+  return `event: response.completed\ndata: ${JSON.stringify(payload)}\n\n`;
+}
+
+async function collectEvents(stream: ReadableStream<Uint8Array>): Promise<{
+  events: ResponseEvent[];
+  error: Error | null;
+}> {
+  const events: ResponseEvent[] = [];
+  let error: Error | null = null;
+
+  try {
+    for await (const event of parseResponsesStream(stream)) {
+      events.push(event);
+    }
+  } catch (err) {
+    error = err as Error;
+  }
+
+  return { events, error };
+}
+
+describe("parseResponsesStream", () => {
+  it("parses output_item.done events and final completed envelope", async () => {
+    const sse = buildSse([
+      responseOutputItemDone({
+        type: "response.output_item.done",
+        item: {
+          type: "message",
+          role: "assistant",
+          content: [{ type: "output_text", text: "Hello" }],
+        },
+      }),
+      responseOutputItemDone({
+        type: "response.output_item.done",
+        item: {
+          type: "message",
+          role: "assistant",
+          content: [{ type: "output_text", text: "World" }],
+        },
+      }),
+      responseCompleted({
+        type: "response.completed",
+        response: { id: "resp1" },
+      }),
+    ]);
 
-describe("ResponsesClientV2", () => {
-  it("placeholder - SSE parsing not implemented", () => {
-    expect(() => {
-      throw new Error("not implemented");
-    }).toThrow("not implemented");
+    const { events, error } = await collectEvents(sse);
+
+    expect(error).toBeNull();
+    expect(events).toHaveLength(3);
+    expect(events[0]).toMatchObject({
+      type: "output_item.done",
+      item: { type: "message", role: "assistant" },
+    });
+    expect(events[1]).toMatchObject({
+      type: "output_item.done",
+      item: { type: "message", role: "assistant" },
+    });
+    expect(events[2]).toEqual({
+      type: "completed",
+      responseId: "resp1",
+      tokenUsage: null,
+    });
+  });
+
+  it("reports an error when response.completed is missing", async () => {
+    const sse = buildSse([
+      responseOutputItemDone({
+        type: "response.output_item.done",
+        item: {
+          type: "message",
+          role: "assistant",
+          content: [{ type: "output_text", text: "Hello" }],
+        },
+      }),
+    ]);
+
+    const { events, error } = await collectEvents(sse);
+
+    expect(events).toHaveLength(1);
+    expect(events[0]).toMatchObject({
+      type: "output_item.done",
+    });
+    expect(error).toBeInstanceOf(Error);
+    expect(error?.message).toBe("stream closed before response.completed");
   });
 });

file update:
diff --git a/src/client-v2/responses.ts b/src/client-v2/responses.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ef91b7388e0669b55a868e803390209c77adf2b9
--- /dev/null
+++ b/src/client-v2/responses.ts
@@ -0,0 +1,19 @@
+import type { ResponseEvent } from "../protocol/types";
+
+/**
+ * Temporary stub for the v2 Responses client stream parser.
+ *
+ * The real implementation will mirror the Rust SSE parser, yielding
+ * {@link ResponseEvent} objects as the OpenAI Responses API emits data.
+ */
+export function parseResponsesStream(
+  stream: ReadableStream<Uint8Array>,
+): AsyncGenerator<ResponseEvent, void, unknown> {
+  void stream;
+
+  return (async function* (): AsyncGenerator<ResponseEvent, void, unknown> {
+    // The initial implementation intentionally yields nothing so that the
+    // accompanying tests fail until the real parser is ported.
+    return;
+  })();
+}
diff --git a/src/protocol/types.ts b/src/protocol/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..00a6201cdf312e18c2e8cf3991c774d3e420d289
--- /dev/null
+++ b/src/protocol/types.ts
@@ -0,0 +1,166 @@
+export interface TokenUsage {
+  input_tokens: number;
+  input_tokens_details?: unknown;
+  output_tokens: number;
+  output_tokens_details?: unknown;
+  total_tokens: number;
+}
+
+export interface OutputTextContent {
+  type: "output_text" | "text";
+  text: string;
+}
+
+export interface InputTextContent {
+  type: "input_text";
+  text: string;
+}
+
+export interface OutputImageContent {
+  type: "output_image";
+  image_url: string;
+  alt_text?: string | null;
+}
+
+export interface InputImageContent {
+  type: "input_image";
+  image_url: string;
+}
+
+export interface ReasoningTextContent {
+  type: "reasoning_text";
+  text: string;
+}
+
+export interface ReasoningSummaryTextContent {
+  type: "summary_text";
+  text: string;
+}
+
+export type ResponseContentItem =
+  | OutputTextContent
+  | InputTextContent
+  | OutputImageContent
+  | InputImageContent
+  | ReasoningTextContent
+  | ReasoningSummaryTextContent
+  | { type: string; [key: string]: unknown };
+
+export interface ResponseMessageItem {
+  type: "message";
+  role: string;
+  content: ResponseContentItem[];
+  id?: string;
+  name?: string;
+  call_id?: string;
+}
+
+export interface ReasoningSummary {
+  type: "summary_text";
+  text: string;
+}
+
+export interface ReasoningContent {
+  type: "reasoning_text" | "text";
+  text: string;
+}
+
+export interface ResponseReasoningItem {
+  type: "reasoning";
+  id?: string;
+  summary: ReasoningSummary[];
+  content?: ReasoningContent[];
+  encrypted_content?: string | null;
+}
+
+export interface LocalShellStatusBase {
+  type: "local_shell_call";
+  id?: string;
+  call_id?: string;
+  status: "completed" | "in_progress" | "incomplete";
+}
+
+export interface LocalShellExecAction {
+  type: "exec";
+  command: string[];
+  timeout_ms?: number | null;
+  working_directory?: string | null;
+  env?: Record<string, string>;
+  user?: string | null;
+}
+
+export interface ResponseLocalShellCallItem extends LocalShellStatusBase {
+  action: LocalShellExecAction | { type: string; [key: string]: unknown };
+}
+
+export interface ResponseFunctionCallItem {
+  type: "function_call";
+  id?: string;
+  name: string;
+  arguments: string;
+  call_id: string;
+}
+
+export interface FunctionCallOutputPayload {
+  content: string;
+  success?: boolean;
+}
+
+export interface ResponseFunctionCallOutputItem {
+  type: "function_call_output";
+  call_id: string;
+  output: FunctionCallOutputPayload;
+}
+
+export interface ResponseCustomToolCallItem {
+  type: "custom_tool_call";
+  id?: string;
+  status?: string;
+  call_id: string;
+  name: string;
+  input: string;
+}
+
+export interface ResponseCustomToolCallOutputItem {
+  type: "custom_tool_call_output";
+  call_id: string;
+  output: string;
+}
+
+export interface ResponseWebSearchCallItem {
+  type: "web_search_call";
+  id?: string;
+  status?: string;
+  action: {
+    type: string;
+    query?: string;
+    [key: string]: unknown;
+  };
+}
+
+export interface ResponseOtherItem {
+  type: string;
+  [key: string]: unknown;
+}
+
+export type ResponseItem =
+  | ResponseMessageItem
+  | ResponseReasoningItem
+  | ResponseLocalShellCallItem
+  | ResponseFunctionCallItem
+  | ResponseFunctionCallOutputItem
+  | ResponseCustomToolCallItem
+  | ResponseCustomToolCallOutputItem
+  | ResponseWebSearchCallItem
+  | ResponseOtherItem;
+
+export type ResponseEvent =
+  | { type: "created" }
+  | { type: "output_item.done"; item: ResponseItem }
+  | { type: "completed"; responseId: string; tokenUsage: TokenUsage | null }
+  | { type: "output_text.delta"; delta: string }
+  | { type: "reasoning_summary.delta"; delta: string }
+  | { type: "reasoning_content.delta"; delta: string }
+  | { type: "reasoning_summary.part_added" }
+  | { type: "web_search_call.begin"; callId: string }
+  | { type: "rate_limits"; snapshot: unknown };
diff --git a/tests/client-v2/responses.test.ts b/tests/client-v2/responses.test.ts
index 31dce545da2598505e9b0bbbff3fbcd1619905e3..c4b649112ba5027424a59260197c5cc9b4ff0211
--- a/tests/client-v2/responses.test.ts
+++ b/tests/client-v2/responses.test.ts
@@ -1,9 +1,107 @@
-import { describe, it, expect } from "bun:test";
+import { describe, expect, it } from "bun:test";
+import { parseResponsesStream } from "../../src/client-v2/responses";
+import type { ResponseEvent } from "../../src/protocol/types";
+
+function buildSse(events: string[]): ReadableStream<Uint8Array> {
+  const encoder = new TextEncoder();
+  const payload = events.join("") + "\n";
+  return new ReadableStream({
+    start(controller) {
+      controller.enqueue(encoder.encode(payload));
+      controller.close();
+    },
+  });
+}
+
+function responseOutputItemDone(payload: unknown): string {
+  return `event: response.output_item.done\ndata: ${JSON.stringify(payload)}\n\n`;
+}
+
+function responseCompleted(payload: unknown): string {
+  return `event: response.completed\ndata: ${JSON.stringify(payload)}\n\n`;
+}
+
+async function collectEvents(stream: ReadableStream<Uint8Array>): Promise<{
+  events: ResponseEvent[];
+  error: Error | null;
+}> {
+  const events: ResponseEvent[] = [];
+  let error: Error | null = null;
+
+  try {
+    for await (const event of parseResponsesStream(stream)) {
+      events.push(event);
+    }
+  } catch (err) {
+    error = err as Error;
+  }
+
+  return { events, error };
+}
+
+describe("parseResponsesStream", () => {
+  it("parses output_item.done events and final completed envelope", async () => {
+    const sse = buildSse([
+      responseOutputItemDone({
+        type: "response.output_item.done",
+        item: {
+          type: "message",
+          role: "assistant",
+          content: [{ type: "output_text", text: "Hello" }],
+        },
+      }),
+      responseOutputItemDone({
+        type: "response.output_item.done",
+        item: {
+          type: "message",
+          role: "assistant",
+          content: [{ type: "output_text", text: "World" }],
+        },
+      }),
+      responseCompleted({
+        type: "response.completed",
+        response: { id: "resp1" },
+      }),
+    ]);
 
-describe("ResponsesClientV2", () => {
-  it("placeholder - SSE parsing not implemented", () => {
-    expect(() => {
-      throw new Error("not implemented");
-    }).toThrow("not implemented");
+    const { events, error } = await collectEvents(sse);
+
+    expect(error).toBeNull();
+    expect(events).toHaveLength(3);
+    expect(events[0]).toMatchObject({
+      type: "output_item.done",
+      item: { type: "message", role: "assistant" },
+    });
+    expect(events[1]).toMatchObject({
+      type: "output_item.done",
+      item: { type: "message", role: "assistant" },
+    });
+    expect(events[2]).toEqual({
+      type: "completed",
+      responseId: "resp1",
+      tokenUsage: null,
+    });
+  });
+
+  it("reports an error when response.completed is missing", async () => {
+    const sse = buildSse([
+      responseOutputItemDone({
+        type: "response.output_item.done",
+        item: {
+          type: "message",
+          role: "assistant",
+          content: [{ type: "output_text", text: "Hello" }],
+        },
+      }),
+    ]);
+
+    const { events, error } = await collectEvents(sse);
+
+    expect(events).toHaveLength(1);
+    expect(events[0]).toMatchObject({
+      type: "output_item.done",
+    });
+    expect(error).toBeInstanceOf(Error);
+    expect(error?.message).toBe("stream closed before response.completed");
   });
 });


thinking
**Reviewing test failures and plan updates**
Plan update
  ✓ Inspect existing v2 scaffolding and determine required files/tests to port first
  ✓ Port initial SSE parsing tests from Rust client.rs into Bun tests (failing state)
  → Create protocol types stub aligning with ResponseItem structure to satisfy tests later
file update:
diff --git a/src/client-v2/responses.ts b/src/client-v2/responses.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ef91b7388e0669b55a868e803390209c77adf2b9
--- /dev/null
+++ b/src/client-v2/responses.ts
@@ -0,0 +1,19 @@
+import type { ResponseEvent } from "../protocol/types";
+
+/**
+ * Temporary stub for the v2 Responses client stream parser.
+ *
+ * The real implementation will mirror the Rust SSE parser, yielding
+ * {@link ResponseEvent} objects as the OpenAI Responses API emits data.
+ */
+export function parseResponsesStream(
+  stream: ReadableStream<Uint8Array>,
+): AsyncGenerator<ResponseEvent, void, unknown> {
+  void stream;
+
+  return (async function* (): AsyncGenerator<ResponseEvent, void, unknown> {
+    // The initial implementation intentionally yields nothing so that the
+    // accompanying tests fail until the real parser is ported.
+    return;
+  })();
+}
diff --git a/src/protocol/types.ts b/src/protocol/types.ts
new file mode 100644
index 0000000000000000000000000000000000000000..00a6201cdf312e18c2e8cf3991c774d3e420d289
--- /dev/null
+++ b/src/protocol/types.ts
@@ -0,0 +1,166 @@
+export interface TokenUsage {
+  input_tokens: number;
+  input_tokens_details?: unknown;
+  output_tokens: number;
+  output_tokens_details?: unknown;
+  total_tokens: number;
+}
+
+export interface OutputTextContent {
+  type: "output_text" | "text";
+  text: string;
+}
+
+export interface InputTextContent {
+  type: "input_text";
+  text: string;
+}
+
+export interface OutputImageContent {
+  type: "output_image";
+  image_url: string;
+  alt_text?: string | null;
+}
+
+export interface InputImageContent {
+  type: "input_image";
+  image_url: string;
+}
+
+export interface ReasoningTextContent {
+  type: "reasoning_text";
+  text: string;
+}
+
+export interface ReasoningSummaryTextContent {
+  type: "summary_text";
+  text: string;
+}
+
+export type ResponseContentItem =
+  | OutputTextContent
+  | InputTextContent
+  | OutputImageContent
+  | InputImageContent
+  | ReasoningTextContent
+  | ReasoningSummaryTextContent
+  | { type: string; [key: string]: unknown };
+
+export interface ResponseMessageItem {
+  type: "message";
+  role: string;
+  content: ResponseContentItem[];
+  id?: string;
+  name?: string;
+  call_id?: string;
+}
+
+export interface ReasoningSummary {
+  type: "summary_text";
+  text: string;
+}
+
+export interface ReasoningContent {
+  type: "reasoning_text" | "text";
+  text: string;
+}
+
+export interface ResponseReasoningItem {
+  type: "reasoning";
+  id?: string;
+  summary: ReasoningSummary[];
+  content?: ReasoningContent[];
+  encrypted_content?: string | null;
+}
+
+export interface LocalShellStatusBase {
+  type: "local_shell_call";
+  id?: string;
+  call_id?: string;
+  status: "completed" | "in_progress" | "incomplete";
+}
+
+export interface LocalShellExecAction {
+  type: "exec";
+  command: string[];
+  timeout_ms?: number | null;
+  working_directory?: string | null;
+  env?: Record<string, string>;
+  user?: string | null;
+}
+
+export interface ResponseLocalShellCallItem extends LocalShellStatusBase {
+  action: LocalShellExecAction | { type: string; [key: string]: unknown };
+}
+
+export interface ResponseFunctionCallItem {
+  type: "function_call";
+  id?: string;
+  name: string;
+  arguments: string;
+  call_id: string;
+}
+
+export interface FunctionCallOutputPayload {
+  content: string;
+  success?: boolean;
+}
+
+export interface ResponseFunctionCallOutputItem {
+  type: "function_call_output";
+  call_id: string;
+  output: FunctionCallOutputPayload;
+}
+
+export interface ResponseCustomToolCallItem {
+  type: "custom_tool_call";
+  id?: string;
+  status?: string;
+  call_id: string;
+  name: string;
+  input: string;
+}
+
+export interface ResponseCustomToolCallOutputItem {
+  type: "custom_tool_call_output";
+  call_id: string;
+  output: string;
+}
+
+export interface ResponseWebSearchCallItem {
+  type: "web_search_call";
+  id?: string;
+  status?: string;
+  action: {
+    type: string;
+    query?: string;
+    [key: string]: unknown;
+  };
+}
+
+export interface ResponseOtherItem {
+  type: string;
+  [key: string]: unknown;
+}
+
+export type ResponseItem =
+  | ResponseMessageItem
+  | ResponseReasoningItem
+  | ResponseLocalShellCallItem
+  | ResponseFunctionCallItem
+  | ResponseFunctionCallOutputItem
+  | ResponseCustomToolCallItem
+  | ResponseCustomToolCallOutputItem
+  | ResponseWebSearchCallItem
+  | ResponseOtherItem;
+
+export type ResponseEvent =
+  | { type: "created" }
+  | { type: "output_item.done"; item: ResponseItem }
+  | { type: "completed"; responseId: string; tokenUsage: TokenUsage | null }
+  | { type: "output_text.delta"; delta: string }
+  | { type: "reasoning_summary.delta"; delta: string }
+  | { type: "reasoning_content.delta"; delta: string }
+  | { type: "reasoning_summary.part_added" }
+  | { type: "web_search_call.begin"; callId: string }
+  | { type: "rate_limits"; snapshot: unknown };
diff --git a/tests/client-v2/responses.test.ts b/tests/client-v2/responses.test.ts
index 31dce545da2598505e9b0bbbff3fbcd1619905e3..c4b649112ba5027424a59260197c5cc9b4ff0211
--- a/tests/client-v2/responses.test.ts
+++ b/tests/client-v2/responses.test.ts
@@ -1,9 +1,107 @@
-import { describe, it, expect } from "bun:test";
+import { describe, expect, it } from "bun:test";
+import { parseResponsesStream } from "../../src/client-v2/responses";
+import type { ResponseEvent } from "../../src/protocol/types";
+
+function buildSse(events: string[]): ReadableStream<Uint8Array> {
+  const encoder = new TextEncoder();
+  const payload = events.join("") + "\n";
+  return new ReadableStream({
+    start(controller) {
+      controller.enqueue(encoder.encode(payload));
+      controller.close();
+    },
+  });
+}
+
+function responseOutputItemDone(payload: unknown): string {
+  return `event: response.output_item.done\ndata: ${JSON.stringify(payload)}\n\n`;
+}
+
+function responseCompleted(payload: unknown): string {
+  return `event: response.completed\ndata: ${JSON.stringify(payload)}\n\n`;
+}
+
+async function collectEvents(stream: ReadableStream<Uint8Array>): Promise<{
+  events: ResponseEvent[];
+  error: Error | null;
+}> {
+  const events: ResponseEvent[] = [];
+  let error: Error | null = null;
+
+  try {
+    for await (const event of parseResponsesStream(stream)) {
+      events.push(event);
+    }
+  } catch (err) {
+    error = err as Error;
+  }
+
+  return { events, error };
+}
+
+describe("parseResponsesStream", () => {
+  it("parses output_item.done events and final completed envelope", async () => {
+    const sse = buildSse([
+      responseOutputItemDone({
+        type: "response.output_item.done",
+        item: {
+          type: "message",
+          role: "assistant",
+          content: [{ type: "output_text", text: "Hello" }],
+        },
+      }),
+      responseOutputItemDone({
+        type: "response.output_item.done",
+        item: {
+          type: "message",
+          role: "assistant",
+          content: [{ type: "output_text", text: "World" }],
+        },
+      }),
+      responseCompleted({
+        type: "response.completed",
+        response: { id: "resp1" },
+      }),
+    ]);
 
-describe("ResponsesClientV2", () => {
-  it("placeholder - SSE parsing not implemented", () => {
-    expect(() => {
-      throw new Error("not implemented");
-    }).toThrow("not implemented");
+    const { events, error } = await collectEvents(sse);
+
+    expect(error).toBeNull();
+    expect(events).toHaveLength(3);
+    expect(events[0]).toMatchObject({
+      type: "output_item.done",
+      item: { type: "message", role: "assistant" },
+    });
+    expect(events[1]).toMatchObject({
+      type: "output_item.done",
+      item: { type: "message", role: "assistant" },
+    });
+    expect(events[2]).toEqual({
+      type: "completed",
+      responseId: "resp1",
+      tokenUsage: null,
+    });
+  });
+
+  it("reports an error when response.completed is missing", async () => {
+    const sse = buildSse([
+      responseOutputItemDone({
+        type: "response.output_item.done",
+        item: {
+          type: "message",
+          role: "assistant",
+          content: [{ type: "output_text", text: "Hello" }],
+        },
+      }),
+    ]);
+
+    const { events, error } = await collectEvents(sse);
+
+    expect(events).toHaveLength(1);
+    expect(events[0]).toMatchObject({
+      type: "output_item.done",
+    });
+    expect(error).toBeInstanceOf(Error);
+    expect(error?.message).toBe("stream closed before response.completed");
   });
 });
