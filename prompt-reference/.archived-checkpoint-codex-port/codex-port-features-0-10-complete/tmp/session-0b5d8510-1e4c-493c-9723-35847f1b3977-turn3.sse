{"type":"tool_use","call_id":"call_SNTMlCtwJQTaKAxIaL4h8vu8","name":"read_file","input":{"file_path":"/Users/leemoore/code/v/codex-port/src/agent/turn.ts"}}
{"type":"tool_result","call_id":"call_SNTMlCtwJQTaKAxIaL4h8vu8","output":{"content":"L1: import { ResponsesClient } from \"../client/responses\";\nL2: import type { ResponsesRequest, StreamItem, TokenUsage } from \"../client/types\";\nL3: import { TOOL_REGISTRY } from \"../tools/registry\";\nL4: import { appendHistory, loadSession, saveSession, type SessionItem } from \"./session\";\nL5: import { constructPrompt } from \"./prompt\";\nL6: \nL7: export interface TurnResult {\nL8:   items: SessionItem[];\nL9:   usage: TokenUsage | null;\nL10: }\nL11: \nL12: export interface RunTurnOptions {\nL13:   responsesClient?: ResponsesClient;\nL14:   promptBuilder?: (items: SessionItem[], opts?: { promptCacheKey?: string }) => ResponsesRequest;\nL15:   toolRegistry?: Record<string, (input: unknown) => Promise<unknown>>;\nL16: }\nL17: \nL18: const MAX_ATTEMPTS = 3;\nL19: const RETRY_DELAYS_MS = [200, 400];\nL20: \nL21: type ResponsesStream = AsyncIterable<StreamItem> & {\nL22:   usage: TokenUsage | null;\nL23:   responseId: string | null;\nL24: };\nL25: \nL26: interface UsageStreamItem {\nL27:   type: \"usage\";\nL28:   usage: TokenUsage | null;\nL29: }\nL30: \nL31: export type TurnStreamItem = SessionItem | UsageStreamItem;\nL32: \nL33: const USER_INSTRUCTIONS_OPEN_TAG = \"<user_instructions>\";\nL34: const USER_INSTRUCTIONS_CLOSE_TAG = \"</user_instructions>\";\nL35: \nL36: class ToolExecutionError extends Error {\nL37:   public readonly cause: unknown;\nL38: \nL39:   constructor(message: string, cause?: unknown) {\nL40:     super(message);\nL41:     this.name = \"ToolExecutionError\";\nL42:     this.cause = cause;\nL43:   }\nL44: }\nL45: \nL46: export async function runTurn(\nL47:   sessionId: string,\nL48:   message: string,\nL49:   options: RunTurnOptions = {},\nL50: ): Promise<TurnResult> {\nL51:   const session = await loadSession(sessionId);\nL52: \nL53:   const userItem: SessionItem = {\nL54:     role: \"user\",\nL55:     content: [{ type: \"input_text\", text: message }],\nL56:   };\nL57:   session.items.push(userItem);\nL58: \nL59:   const promptBuilder = options.promptBuilder ?? constructPrompt;\nL60:   const responsesClient = options.responsesClient ?? new ResponsesClient();\nL61:   const toolRegistry = options.toolRegistry ?? TOOL_REGISTRY;\nL62: \nL63:   let usage: TokenUsage | null = null;\nL64:   let lastError: unknown = null;\nL65: \nL66:   for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt += 1) {\nL67:     const attemptStartIndex = session.items.length;\nL68:     try {\nL69:       let responseId: string | null = null;\nL70:       let pendingToolSubmissions: Array<{ callId: string; name: string; input: unknown; output: unknown }> | null = null;\nL71: \nL72:       while (true) {\nL73:         const promptItems = withSessionInstructions(\nL74:           [...session.items],\nL75:           session.session.instructions,\nL76:         );\nL77:         const basePrompt = promptBuilder(promptItems, { promptCacheKey: sessionId });\nL78: \nL79:         let request: ResponsesRequest = { ...basePrompt };\nL80:         \nL81:         if (pendingToolSubmissions && pendingToolSubmissions.length > 0) {\nL82:           // For ChatGPT Codex, include both the function_call and its function_call_output\nL83:           // in the same request. Do not rely on previous_response_id.\nL84:           const toolInputs = pendingToolSubmissions.flatMap((submission) => [\nL85:             {\nL86:               type: \"function_call\",\nL87:               name: submission.name,\nL88:               arguments: JSON.stringify(submission.input ?? {}),\nL89:               call_id: submission.callId,\nL90:             },\nL91:             {\nL92:               type: \"function_call_output\",\nL93:               call_id: submission.callId,\nL94:               output: formatToolOutputForModel(submission.output),\nL95:             },\nL96:           ]);\nL97:           // Keep the full conversation context (messages) and append the\nL98:           // function_call + function_call_output pair as explicit input so the\nL99:           // model can ground its final reply in the user question.\nL100:           request = {\nL101:             ...request,\nL102:             input: toolInputs,\nL103:           };\nL104:         } else if (responseId) {\nL105:           request = { ...request, previous_response_id: responseId };\nL106:         }\nL107: \nL108:         const stream = (await responsesClient.create(request)) as ResponsesStream;\nL109:         const {\nL110:           items: producedItems,\nL111:           usage: attemptUsage,\nL112:           toolSubmissions,\nL113:         } = await collectStreamItems(stream, toolRegistry);\nL114: \nL115:         session.items.push(...producedItems);\nL116:         if (attemptUsage) {\nL117:           usage = attemptUsage;\nL118:         }\nL119:         responseId = stream.responseId;\nL120: \nL121:         if (toolSubmissions.length > 0) {\nL122:           pendingToolSubmissions = toolSubmissions;\nL123:           continue;\nL124:         }\nL125: \nL126:         pendingToolSubmissions = null;\nL127:         await saveSession(session);\nL128:         await appendHistory(sessionId, message);\nL129: \nL130:         return {\nL131:           items: session.items,\nL132:           usage,\nL133:         };\nL134:       }\nL135:     } catch (error) {\nL136:       lastError = error;\nL137:       session.items.splice(attemptStartIndex);\nL138: \nL139:       if (error instanceof ToolExecutionError) {\nL140:         throw error;\nL141:       }\nL142: \nL143:       if (attempt < MAX_ATTEMPTS - 1) {\nL144:         const delay =\nL145:           RETRY_DELAYS_MS[Math.min(attempt, RETRY_DELAYS_MS.length - 1)];\nL146:         await sleep(delay);\nL147:         continue;\nL148:       }\nL149:     }\nL150:   }\nL151: \nL152:   if (lastError instanceof Error) {\nL153:     throw lastError;\nL154:   }\nL155:   throw new Error(String(lastError));\nL156: }\nL157: \nL158: export async function* runTurnStream(\nL159:   sessionId: string,\nL160:   message: string,\nL161:   options: RunTurnOptions = {},\nL162: ): AsyncGenerator<TurnStreamItem, void, undefined> {\nL163:   const session = await loadSession(sessionId);\nL164: \nL165:   const userItem: SessionItem = {\nL166:     role: \"user\",\nL167:     content: [{ type: \"input_text\", text: message }],\nL168:   };\nL169:   session.items.push(userItem);\nL170: \nL171:   const promptBuilder = options.promptBuilder ?? constructPrompt;\nL172:   const responsesClient = options.responsesClient ?? new ResponsesClient();\nL173:   const toolRegistry = options.toolRegistry ?? TOOL_REGISTRY;\nL174: \nL175:   let lastError: unknown = null;\nL176: \nL177:   for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt += 1) {\nL178:     const attemptStartIndex = session.items.length;\nL179:     try {\nL180:       let responseId: string | null = null;\nL181:       let pendingToolSubmissions: Array<{ callId: string; name: string; input: unknown; output: unknown }> | null = null;\nL182: \nL183:       while (true) {\nL184:         const promptItems = withSessionInstructions(\nL185:           [...session.items],\nL186:           session.session.instructions,\nL187:         );\nL188:         const basePrompt = promptBuilder(promptItems, { promptCacheKey: sessionId });\nL189: \nL190:         let request: ResponsesRequest = { ...basePrompt };\nL191:         if (pendingToolSubmissions && pendingToolSubmissions.length > 0) {\nL192:           const toolInputs = pendingToolSubmissions.flatMap((submission) => [\nL193:             {\nL194:               type: \"function_call\",\nL195:               name: submission.name,\nL196:               arguments: JSON.stringify(submission.input ?? {}),\nL197:               call_id: submission.callId,\nL198:             },\nL199:             {\nL200:               type: \"function_call_output\",\nL201:               call_id: submission.callId,\nL202:               output: formatToolOutputForModel(submission.output),\nL203:             },\nL204:           ]);\nL205:           request = {\nL206:             ...request,\nL207:             input: toolInputs,\nL208:           };\nL209:         } else if (responseId) {\nL210:           request = { ...request, previous_response_id: responseId };\nL211:         }\nL212: \nL213:         const stream = (await responsesClient.create(request)) as ResponsesStream;\nL214:         const attemptItems: SessionItem[] = [];\nL215:         const toolSubmissions: Array<{ callId: string; name: string; input: unknown; output: unknown }> = [];\nL216: \nL217:         for await (const rawItem of stream) {\nL218:           const conversion = await convertStreamItem(rawItem, toolRegistry);\nL219:           if (conversion.submission) {\nL220:             toolSubmissions.push(conversion.submission);\nL221:           }\nL222:           for (const producedItem of conversion.items) {\nL223:             attemptItems.push(producedItem);\nL224:             yield producedItem;\nL225:           }\nL226:         }\nL227: \nL228:         const usage = stream.usage ?? null;\nL229:         session.items.push(...attemptItems);\nL230:         responseId = stream.responseId;\nL231: \nL232:         if (toolSubmissions.length > 0) {\nL233:           pendingToolSubmissions = toolSubmissions;\nL234:           continue;\nL235:         }\nL236: \nL237:         pendingToolSubmissions = null;\nL238:         await saveSession(session);\nL239:         await appendHistory(sessionId, message);\nL240: \nL241:         yield { type: \"usage\", usage };\nL242:         return;\nL243:       }\nL244:     } catch (error) {\nL245:       lastError = error;\nL246:       session.items.splice(attemptStartIndex);\nL247: \nL248:       if (error instanceof ToolExecutionError) {\nL249:         throw error;\nL250:       }\nL251: \nL252:       if (attempt < MAX_ATTEMPTS - 1) {\nL253:         const delay =\nL254:           RETRY_DELAYS_MS[Math.min(attempt, RETRY_DELAYS_MS.length - 1)];\nL255:         await sleep(delay);\nL256:         continue;\nL257:       }\nL258:     }\nL259:   }\nL260: \nL261:   if (lastError instanceof Error) {\nL262:     throw lastError;\nL263:   }\nL264:   throw new Error(String(lastError));\nL265: }\nL266: \nL267: async function collectStreamItems(\nL268:   stream: ResponsesStream,\nL269:   toolRegistry: Record<string, (input: unknown) => Promise<unknown>>,\nL270: ): Promise<{\nL271:   items: SessionItem[];\nL272:   usage: TokenUsage | null;\nL273:   toolSubmissions: Array<{ callId: string; name: string; input: unknown; output: unknown }>;\nL274: }> {\nL275:   const collected: SessionItem[] = [];\nL276:   const submissions: Array<{ callId: string; name: string; input: unknown; output: unknown }> = [];\nL277: \nL278:   for await (const rawItem of stream) {\nL279:     const conversion = await convertStreamItem(rawItem, toolRegistry);\nL280:     collected.push(...conversion.items);\nL281:     if (conversion.submission) {\nL282:       submissions.push(conversion.submission);\nL283:     }\nL284:   }\nL285: \nL286:   return {\nL287:     items: collected,\nL288:     usage: stream.usage ?? null,\nL289:     toolSubmissions: submissions,\nL290:   };\nL291: }\nL292: \nL293: async function convertStreamItem(\nL294:   item: StreamItem,\nL295:   toolRegistry: Record<string, (input: unknown) => Promise<unknown>>,\nL296: ): Promise<{ items: SessionItem[]; submission?: { callId: string; name: string; input: unknown; output: unknown } }> {\nL297:   if (\"role\" in item) {\nL298:     return {\nL299:       items: [\nL300:         {\nL301:           role: item.role,\nL302:           content: item.content.map((part) => ({\nL303:             type: part.type,\nL304:             text: part.text,\nL305:           })),\nL306:         },\nL307:       ],\nL308:     };\nL309:   }\nL310: \nL311:   if (item.type === \"tool_use\") {\nL312:     const toolUseItem: SessionItem = {\nL313:       type: \"tool_use\",\nL314:       call_id: item.call_id,\nL315:       name: item.name,\nL316:       input: item.input,\nL317:     };\nL318: \nL319:     console.debug(\"[turn] tool_use item\", JSON.stringify(item));\nL320: \nL321:     const handler = toolRegistry[item.name];\nL322:     if (!handler) {\nL323:       console.error(\nL324:         \"[turn] tool not found\",\nL325:         JSON.stringify({ callId: item.call_id, name: item.name }),\nL326:       );\nL327:       throw new ToolExecutionError(`Tool not found: ${item.name}`);\nL328:     }\nL329: \nL330:     const normalizedInput = item.input;\nL331: \nL332:     try {\nL333:       console.debug(\nL334:         \"[turn] invoking tool\",\nL335:         JSON.stringify({ callId: item.call_id, name: item.name, input: normalizedInput }),\nL336:       );\nL337:       const output = await handler(normalizedInput);\nL338:       console.debug(\nL339:         \"[turn] tool succeeded\",\nL340:         JSON.stringify({ callId: item.call_id, name: item.name }),\nL341:       );\nL342:       const toolResult: SessionItem = {\nL343:         type: \"tool_result\",\nL344:         call_id: item.call_id,\nL345:         output,\nL346:       };\nL347: \nL348:       return {\nL349:         items: [toolUseItem, toolResult],\nL350:         submission: {\nL351:           callId: item.call_id,\nL352:           name: item.name,\nL353:           input: normalizedInput,\nL354:           output,\nL355:         },\nL356:       };\nL357:     } catch (error) {\nL358:       const message = formatToolError(error);\nL359:       console.error(\nL360:         \"[turn] tool failure\",\nL361:         JSON.stringify({\nL362:           callId: item.call_id,\nL363:           name: item.name,\nL364:           input: normalizedInput,\nL365:           error: message,\nL366:         }),\nL367:       );\nL368: \nL369:       const failureOutput = {\nL370:         success: false,\nL371:         error: message,\nL372:       };\nL373: \nL374:       const toolResult: SessionItem = {\nL375:         type: \"tool_result\",\nL376:         call_id: item.call_id,\nL377:         output: failureOutput,\nL378:       };\nL379: \nL380:       return {\nL381:         items: [toolUseItem, toolResult],\nL382:         submission: {\nL383:           callId: item.call_id,\nL384:           name: item.name,\nL385:           input: normalizedInput,\nL386:           output: failureOutput,\nL387:         },\nL388:       };\nL389:     }\nL390:   }\nL391: \nL392:   return { items: [] };\nL393: }\nL394: \nL395: function sleep(delayMs: number): Promise<void> {\nL396:   return new Promise((resolve) => {\nL397:     setTimeout(resolve, delayMs);\nL398:   });\nL399: }\nL400: \nL401: function formatToolError(error: unknown): string {\nL402:   if (error instanceof Error) {\nL403:     return error.message;\nL404:   }\nL405:   if (typeof error === \"string\") {\nL406:     return error;\nL407:   }\nL408:   return JSON.stringify(error);\nL409: }\nL410: \nL411: function formatToolOutputForModel(output: unknown): string {\nL412:   if (typeof output === \"string\") {\nL413:     return output;\nL414:   }\nL415: \nL416:   if (output && typeof output === \"object\") {\nL417:     const record = output as Record<string, unknown>;\nL418:     if (typeof record.content === \"string\") {\nL419:       return record.content;\nL420:     }\nL421:     if (typeof record.error === \"string\") {\nL422:       return record.error;\nL423:     }\nL424:   }\nL425: \nL426:   try {\nL427:     return output === undefined ? \"\" : JSON.stringify(output);\nL428:   } catch {\nL429:     return String(output ?? \"\");\nL430:   }\nL431: }\nL432: \nL433: function withSessionInstructions(\nL434:   items: SessionItem[],\nL435:   instructions: string | undefined,\nL436: ): SessionItem[] {\nL437:   const text = instructions ?? \"\";\nL438:   if (!text.trim()) {\nL439:     return withEnvironmentContext(items);\nL440:   }\nL441: \nL442:   const instructionItem: SessionItem = {\nL443:     role: \"user\",\nL444:     content: [\nL445:       {\nL446:         type: \"input_text\",\nL447:         text: formatUserInstructions(text),\nL448:       },\nL449:     ],\nL450:   };\nL451: \nL452:   return [instructionItem, ...withEnvironmentContext(items)];\nL453: }\nL454: \nL455: function formatUserInstructions(text: string): string {\nL456:   return `${USER_INSTRUCTIONS_OPEN_TAG}\\n\\n${text}\\n\\n${USER_INSTRUCTIONS_CLOSE_TAG}`;\nL457: }\nL458: \nL459: function withEnvironmentContext(items: SessionItem[]): SessionItem[] {\nL460:   return [createEnvironmentContextItem(), ...items];\nL461: }\nL462: \nL463: function createEnvironmentContextItem(): SessionItem {\nL464:   const cwd = escapeForXml(process.cwd());\nL465:   const approvalPolicy = readEnvValue(\"CODEX_APPROVAL_POLICY\");\nL466:   const sandboxMode = readEnvValue(\"CODEX_SANDBOX_MODE\");\nL467:   const networkAccess = readEnvValue(\"CODEX_NETWORK_ACCESS\");\nL468:   const writableRoots = readWritableRoots();\nL469:   const shellName = extractShellName();\nL470: \nL471:   const lines: string[] = [\"<environment_context>\"];\nL472:   lines.push(`  <cwd>${cwd}</cwd>`);\nL473:   if (approvalPolicy) {\nL474:     lines.push(`  <approval_policy>${escapeForXml(approvalPolicy)}</approval_policy>`);\nL475:   }\nL476:   if (sandboxMode) {\nL477:     lines.push(`  <sandbox_mode>${escapeForXml(sandboxMode)}</sandbox_mode>`);\nL478:   }\nL479:   if (networkAccess) {\nL480:     lines.push(`  <network_access>${escapeForXml(networkAccess)}</network_access>`);\nL481:   }\nL482:   if (writableRoots.length > 0) {\nL483:     lines.push(\"  <writable_roots>\");\nL484:     for (const root of writableRoots) {\nL485:       lines.push(`    <root>${escapeForXml(root)}</root>`);\nL486:     }\nL487:     lines.push(\"  </writable_roots>\");\nL488:   }\nL489:   if (shellName) {\nL490:     lines.push(`  <shell>${escapeForXml(shellName)}</shell>`);\nL491:   }\nL492:   lines.push(\"</environment_context>\");\nL493: \nL494:   return {\nL495:     role: \"user\",\nL496:     content: [\nL497:       {\nL498:         type: \"input_text\",\nL499:         text: lines.join(\"\\n\"),\nL500:       },\nL501:     ],\nL502:   };\nL503: }\nL504: \nL505: function readEnvValue(key: string): string | null {\nL506:   const value = process.env[key];\nL507:   if (!value) {\nL508:     return null;\nL509:   }\nL510:   const trimmed = value.trim();\nL511:   return trimmed.length > 0 ? trimmed : null;\nL512: }\nL513: \nL514: function readWritableRoots(): string[] {\nL515:   const raw = readEnvValue(\"CODEX_WRITABLE_ROOTS\");\nL516:   if (!raw) {\nL517:     return [];\nL518:   }\nL519:   const delimiter = process.platform === \"win32\" ? \";\" : \":\";\nL520:   return raw\nL521:     .split(delimiter)\nL522:     .map((part) => part.trim())\nL523:     .filter((part) => part.length > 0);\nL524: }\nL525: \nL526: function extractShellName(): string | null {\nL527:   const explicit = readEnvValue(\"CODEX_SHELL_NAME\");\nL528:   if (explicit) {\nL529:     return explicit;\nL530:   }\nL531:   const shellPath = readEnvValue(\"SHELL\");\nL532:   if (!shellPath) {\nL533:     return null;\nL534:   }\nL535:   const segments = shellPath.split(/[/\\\\]/).filter(Boolean);\nL536:   return segments.pop() ?? null;\nL537: }\nL538: \nL539: function escapeForXml(value: string): string {\nL540:   return value\nL541:     .replace(/&/g, \"&amp;\")\nL542:     .replace(/</g, \"&lt;\")\nL543:     .replace(/>/g, \"&gt;\")\nL544:     .replace(/\\\"/g, \"&quot;\")\nL545:     .replace(/'/g, \"&apos;\");\nL546: }","success":true}}
{"role":"assistant","content":[{"type":"text","text":"- Loads the session, records the incoming user message, and resolves prompt builder, responses client, and tool registry defaults from options or fallbacks `src/agent/turn.ts:51` `src/agent/turn.ts:57` `src/agent/turn.ts:59` `src/agent/turn.ts:61`.\n- Wraps execution in up to three retry attempts, tracking where new items start and trimming on failure before optionally delaying and retrying `src/agent/turn.ts:66` `src/agent/turn.ts:137` `src/agent/turn.ts:144`.\n- On each pass, rebuilds the prompt with session instructions, replays any pending tool call outputs, otherwise chains via `previous_response_id`, and invokes the responses client stream `src/agent/turn.ts:73` `src/agent/turn.ts:100` `src/agent/turn.ts:105` `src/agent/turn.ts:108`.\n- Collects streamed items and tool submissions, updates session state and usage, persists session plus history, and returns the aggregated items once no further tool calls are pending `src/agent/turn.ts:109` `src/agent/turn.ts:115` `src/agent/turn.ts:122` `src/agent/turn.ts:127` `src/agent/turn.ts:131`."}]}
{"type":"usage","usage":{"input_tokens":10798,"input_tokens_details":{"cached_tokens":0},"output_tokens":863,"output_tokens_details":{"reasoning_tokens":576},"total_tokens":11661}}
